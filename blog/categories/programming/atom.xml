<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Programming | My Little Garden of Code]]></title>
  <link href="http://philtomson.github.io/blog/categories/programming/atom.xml" rel="self"/>
  <link href="http://philtomson.github.io/"/>
  <updated>2017-02-02T17:21:37-08:00</updated>
  <id>http://philtomson.github.io/</id>
  <author>
    <name><![CDATA[Phil Tomson]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Coding Happy Little Trees: Tree Meditation #1]]></title>
    <link href="http://philtomson.github.io/blog/2014/04/29/coding-pretty-little-trees-tree-meditation-number-1/"/>
    <updated>2014-04-29T12:33:00-07:00</updated>
    <id>http://philtomson.github.io/blog/2014/04/29/coding-pretty-little-trees-tree-meditation-number-1</id>
    <content type="html"><![CDATA[<p><img src="http://t3.gstatic.com/images?q=tbn:ANd9GcSIjEBactvxvvUkh6DVgHT2Dan9e57x3nbGbq5RdzjwXkcV4V1r" title="Bob Ross, master of happy trees" alt="Alt Bob Ross" /></p>

<p><em>It all started a few months ago when I created a quad-tree structure and
then wanted to be able to visualize those trees with GraphViz. Thus
  this tree meditation was born. And who was the master of happy little trees? <a href="http://en.wikipedia.org/wiki/Bob_Ross">Bob Ross</a> of course. So if you like, read the following in Bob&rsquo;s very relaxing voice&hellip;. try not to go to sleep.</em></p>

<p>Before we can code our happy little trees we need to define what a tree is:</p>

<p><figure class='code'><figcaption><span>[ ] [title: binary tree type in OCaml] </span></figcaption>
<div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='ocaml'><span class='line'><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">h1</span><span class="o">&gt;</span><span class="k">type</span> <span class="o">&amp;</span><span class="n">lsquo</span><span class="o">;</span><span class="n">a</span> <span class="n">tree</span> <span class="o">=</span> <span class="nc">Empty</span> <span class="o">|</span> <span class="nc">Leaf</span> <span class="k">of</span> <span class="k">&#39;</span><span class="n">a</span> <span class="o">|</span> <span class="nc">Node</span> <span class="k">of</span> <span class="k">&#39;</span><span class="n">a</span> <span class="n">tree</span> <span class="o">*</span> <span class="k">&#39;</span><span class="n">a</span> <span class="o">*</span> <span class="k">&#39;</span><span class="n">a</span> <span class="n">tree</span> <span class="o">;;&lt;/</span><span class="n">h1</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span>
</span></code></pre></td></tr></table></div></figure></p>

<p>You can go ahead and type that yourself into the <a href="http://try.ocamlpro.com/">online OCaml REPL (Read Evaluate Print Loop)</a>. Go ahead, give it a try.</p>

<p>The type definition here is in <a href="http://ocaml.org/">OCaml</a>. The ML family of languages (SML, OCaml and Haskell, for example) excel at creating pretty trees because they have <a href="http://en.wikipedia.org/wiki/Algebraic_data_type">algebraic data types</a>. What&rsquo;s the <em>&lsquo;a tree</em> mean? The <em>'a</em> is a type variable and means that we&rsquo;re creating trees which contain data of type <em>'a</em>. Since <em>'a</em> isn&rsquo;t specified it means that any type of data could live in the tree; our tree is <em>polymorphic</em>.</p>

<p>Since this is a SUM type (also called an OR type, notice the &lsquo;|&rsquo;s in the definition above) we can surmise that a tree can either be <em>Empty</em> or have a <em>Leaf</em> or a <em>Node</em>. <em>Empty</em>, <em>Leaf</em> and <em>Node</em> are used to build our tree, they are our tree <em>constructors</em>.</p>

<p><em>Empty</em>, what&rsquo;s that mean? Think of it as the tree of nothingness. Very Zen. Hopefully it will make more sense when we start creating and traversing trees.</p>

<p><em>Leaf of &lsquo;a</em> means that a leaf can contain data of type <em>'a</em> and as was explained above, that means that the leaf can contain data of any type. How do we create a <em>Leaf of 'a</em> in our code?</p>

<p><figure class='code'><figcaption><span>[ ] [title: How to make a leaf] </span></figcaption>
<div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='ocaml'><span class='line'><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">h1</span><span class="o">&gt;</span><span class="nc">Leaf</span> <span class="o">&amp;</span><span class="n">ldquo</span><span class="o">;</span><span class="nc">I</span><span class="o">&amp;</span><span class="n">rsquo</span><span class="o">;</span><span class="n">m</span> <span class="n">a</span> <span class="nc">Leaf</span><span class="o">&amp;</span><span class="n">rdquo</span><span class="o">;</span> <span class="o">;;&lt;/</span><span class="n">h1</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">ul</span><span class="o">&gt;</span>
</span><span class='line'><span class="o">&lt;</span><span class="n">li</span><span class="o">&gt;:</span> <span class="kt">string</span> <span class="n">tree</span> <span class="o">=</span> <span class="nc">Leaf</span> <span class="o">&amp;</span><span class="n">ldquo</span><span class="o">;</span><span class="nc">I</span><span class="o">&amp;</span><span class="n">rsquo</span><span class="o">;</span><span class="n">m</span> <span class="n">a</span> <span class="nc">Leaf</span><span class="o">&amp;</span><span class="n">rdquo</span><span class="o">;</span>
</span></code></pre></td></tr></table></div></figure></li>
</ul>


<p>The above was typed into the OCaml REPL. The <em>#</em> is the REPL prompt, we only typed in the actual <em>Leaf &ldquo;I&rsquo;m a Leaf&rdquo;</em> part. The second line shows the result. Notce that the type is <em>string tree</em> because we passed a string to the <em>Leaf</em> constructor. So our leaf is itself a tree. Ok, maybe that seems a little stange, but hold up a leaf by the stem and it can certainly look like a little tree on it&rsquo;s own, don&rsquo;t you think? Fractals, think fractals.</p>

<p>Now we&rsquo;re left with that <em>Node of &lsquo;a tree * 'a * 'a tree</em> part of the tree type definition. Here we&rsquo;ve reached the essence of <em>treeness</em>. A <em>Node</em> of a tree has three parts: A <em>'a tree</em> on the left, the actual <em>'a</em> data contained by this <em>Node</em> and another <em>'a tree</em> on the right. This part of the definition of <em>tree</em> is recursive because a <em>Node</em> is the piece of a tree which can contain other trees - in our case we have defined a <em>binary</em> tree type since each node has only two branches: a left tree and a right tree. What&rsquo;s with the asterisks? Technically they indicate that this part of the type is a <em>Cartesian product</em> (algebraic datatypes remember). We can think of this particular one as a <em>triple</em> - a collection of 3 things.</p>

<p>So without further ado, let&rsquo;s code a happy little tree:</p>

<p><figure class='code'><figcaption><span>[ ] [title: Our first happy little tree ] </span></figcaption>
<div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='ocaml'><span class='line'><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">h1</span><span class="o">&gt;</span><span class="nc">Node</span><span class="o">(</span><span class="nc">Leaf</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="nc">Leaf</span> <span class="mi">3</span><span class="o">)</span> <span class="o">;;&lt;/</span><span class="n">h1</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">ul</span><span class="o">&gt;</span>
</span><span class='line'><span class="o">&lt;</span><span class="n">li</span><span class="o">&gt;:</span> <span class="kt">int</span> <span class="n">tree</span> <span class="o">=</span> <span class="nc">Node</span> <span class="o">(</span><span class="nc">Leaf</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="nc">Leaf</span> <span class="mi">3</span><span class="o">)</span>
</span></code></pre></td></tr></table></div></figure></li>
</ul>


<p>The REPL tells us this is an <em>int tree</em>, a tree which contains integers at it&rsquo;s nodes and leaves.</p>

<p>And what does it look like?</p>

<p><img src="%20/images/happy_tree.png" alt="Alt Our Happy Tree" /></p>

<p>Notice in this case that we&rsquo;ve got a complete tree; we did not use the <em>Empty</em> constructor. What if we had?</p>

<p><figure class='code'><figcaption><span>[ ] [title: a perhaps less happy little tree ] </span></figcaption>
<div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='ocaml'><span class='line'><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">h1</span><span class="o">&gt;</span><span class="nc">Node</span><span class="o">(</span><span class="nc">Leaf</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="nc">Empty</span><span class="o">)</span> <span class="o">;;&lt;/</span><span class="n">h1</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">ul</span><span class="o">&gt;</span>
</span><span class='line'><span class="o">&lt;</span><span class="n">li</span><span class="o">&gt;:</span> <span class="kt">int</span> <span class="n">tree</span> <span class="o">=</span> <span class="nc">Node</span> <span class="o">(</span><span class="nc">Leaf</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="nc">Empty</span><span class="o">)</span>
</span></code></pre></td></tr></table></div></figure></li>
</ul>


<p>Now we have what is perhaps a less happy little tree. The right branch of our little tree is <em>empty</em>. The <em>Leaf 3</em> has fallen. Now perhaps you can see why we need <em>Empty</em>. <em>Node</em> must have two sub-trees. We can&rsquo;t just do something like:</p>

<p><figure class='code'><figcaption><span>[ ] [title: an erroneous tree ] </span></figcaption>
<div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class='ocaml'><span class='line'><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">h1</span><span class="o">&gt;</span><span class="nc">Node</span><span class="o">(</span><span class="nc">Leaf</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">1</span><span class="o">)</span> <span class="o">;;&lt;/</span><span class="n">h1</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span><span class="nc">File</span> <span class="o">&amp;</span><span class="n">ldquo</span><span class="o">;&amp;</span><span class="n">rdquo</span><span class="o">;,</span> <span class="n">line</span> <span class="mi">1</span><span class="o">,</span> <span class="n">characters</span> <span class="mi">1</span><span class="o">-</span><span class="mi">16</span><span class="o">:</span>
</span><span class='line'><span class="nc">Error</span><span class="o">:</span> <span class="nc">The</span> <span class="n">constructor</span> <span class="nc">Node</span> <span class="n">expects</span> <span class="mi">3</span> <span class="n">argument</span><span class="o">(</span><span class="n">s</span><span class="o">),</span>
</span><span class='line'>       <span class="n">but</span> <span class="n">is</span> <span class="n">applied</span> <span class="n">here</span> <span class="k">to</span> <span class="mi">2</span> <span class="n">argument</span><span class="o">(</span><span class="n">s</span><span class="o">)</span>
</span></code></pre></td></tr></table></div></figure></p>

<p>Because the <em>Node</em> constructor expects to have three components. So <em>Empty</em> is used to designate the absense of a <em>Node</em> or <em>Leaf</em>.</p>

<p>How did I draw that tree above? That&rsquo;ll have to wait for the next Tree Medititation installment when we&rsquo;ll discuss things like <em>tree traversal</em> and generating <em>dot files</em> used by <a href="http://www.graphviz.org/">Graphviz</a> to create images.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[C++ Dusty Corner #5379: 0 Is Sometimes a Special Number]]></title>
    <link href="http://philtomson.github.io/blog/2014/03/07/c-plus-plus-dusty-corner-number-537-0-is-sometimes-a-special/"/>
    <updated>2014-03-07T08:57:00-08:00</updated>
    <id>http://philtomson.github.io/blog/2014/03/07/c-plus-plus-dusty-corner-number-537-0-is-sometimes-a-special</id>
    <content type="html"><![CDATA[<p>I recently discovered the <a href="http://cppquiz.org/">C++ Quiz site</a> and
figuring that it&rsquo;s always good to practice C++ skills I started going
through the questions. The third question I
encountered gave me some pause&hellip;  The question was:</p>

<pre><code>According to the C++11 standard, what is the output of this program?

#include &lt;iostream&gt;

void print(char const *str) { std::cout &lt;&lt; str; }
void print(short num) { std::cout &lt;&lt; num; }

int main() {
  print("abc");
  print(0);
  print('A');
}
</code></pre>

<p>Now the obvious response would be &ldquo;abc065&rdquo;, but I suspected there was some
sort of trickery afoot here. Finally, I just entered &ldquo;abc065&rdquo; and of course
my suspicion was right: the answer was incorrect. Then I went ahead and
&ldquo;cheated&rdquo; by pasting the code into a file and compiling it:</p>

<pre><code>$ g++ -o quiz1 quiz1.cpp
quiz1.cpp: In function ‘int main()’:
quiz1.cpp:9:10: error: call of overloaded ‘print(int)’ is ambiguous
print(0);
      ^
quiz1.cpp:9:10: note: candidates are:
quiz1.cpp:4:6: note: void print(const char*)
void print(char const *str) { std::cout &lt;&lt; str; }
quiz1.cpp:5:6: note: void print(short int)
void print(short num) { std::cout &lt;&lt; num; }
</code></pre>

<p><em>&ldquo;Umm&hellip; ok&rdquo;</em>, I thought <em>&ldquo;shouldn&rsquo;t the int literal 0 be cast to a short
automatically? What gives here?&rdquo;</em>. Maybe clang will give me a more
descriptive error message? It&rsquo;s known for that, right?</p>

<pre><code>$ clang++  -o quiz1 quiz1.cpp
quiz1.cpp:9:3: error: call to 'print' is ambiguous
print(0);
      ^~~~~
quiz1.cpp:4:6: note: candidate function
void print(char const *str) { std::cout &lt;&lt; str; }
quiz1.cpp:5:6: note: candidate function
void print(short num) { std::cout &lt;&lt; num; }
</code></pre>

<p>Ok, so clang didn&rsquo;t reveal any new information here&hellip; other than
those fancy tildas. So I went back to the CPP Quiz site and chose
&ldquo;has compilation error&rdquo; and clicked &lsquo;Answer&rsquo; to get the explanation:</p>

<pre><code>Sneaky ambiguous function call.

The statement print(0); is ambiguous due to overload resolution rules. 
Both print functions are viable, but for the compiler to pick one, 
one of them has to have a better conversion sequence than the other. 
§13.3.3¶2: "If there is exactly one viable function that is a better 
function than all other viable functions, then it is the one selected 
by overload resolution; otherwise the call is ill-formed".

(a) *Because 0 is a null pointer constant[1], it can be converted 
implicitly into any pointer type with a single conversion.*

(b) Because 0 is of type int, it can be converted implicitly to a 
short with a single conversion too.

In our case, both are standard conversion sequences with a single 
conversion of "conversion rank". Since no function is better than 
the other, the call is ill-formed.

[1] §4.10¶1 A null pointer constant is an integral constant expression 
(5.19) prvalue of integer type that evaluates to zero(...) A null 
pointer constant can be converted to a pointer type.
</code></pre>

<p>Ooookaaayy&hellip; so this is one of those occasions where being a C++ programmer
is very much akin to being a lawyer: you need to be up on all of the
provisos, caveats and special exemptions in the law (or in the spec in this
case).</p>

<p>So what happened? Passing &lsquo;0&rsquo; to the <em>print</em> function can interpretted as
either passing a null pointer to the first <em>print</em> function or as a short
0 to the second, overloaded <em>print</em> function. Ok, so couldn&rsquo;t any
integer being passed to the print function also be interpreted as possibly
being a pointer?  So as an experiment I changed:</p>

<pre><code>print(0);
</code></pre>

<p>To:
    print(2);</p>

<p>Of course, then it compiles just fine. So &lsquo;0&rsquo; is a <em>special</em> number in this
context because it&rsquo;s also the null pointer constant.</p>

<p>If you are a programming polyglot like me, your first reaction upon realizing
this is probably to want to run to the relative safety of gated communities
such as OCaml, Haskell or maybe Python where these kinds of incidents
just don&rsquo;t happen (because no pointers -> no NULL -> no special case for 0).
&hellip;until you realize that those neighborhoods have their own, different
quirks and in fact there&rsquo;s no perfect language (well, except for Lisp,
maybe, but <em>which Lisp?</em>).</p>

<p>Sometimes you&rsquo;ve gotta hang out in the C++ hood with all of the sirens
and gunshots in the background in order to get things done. As always, you
just need to be very wary while you&rsquo;re in the C++ hood in order to survive.
Fortunately, in this case it&rsquo;s just a compilation error that seems rather
confusing at first, not a segfault.</p>

<p>Sure it&rsquo;s definitely strange that 0 is a special case integer in this
context, but to be fair, how often would you actually run into this
situation in C++? I&rsquo;d guess it would be very rare. In most cases you
wouldn&rsquo;t be passing a &lsquo;0&rsquo; literal to a function like that - you&rsquo;d instead
be passing in a variable and even if that variable contains &lsquo;0&rsquo;, that&rsquo;s
just fine.</p>
]]></content>
  </entry>
  
</feed>
