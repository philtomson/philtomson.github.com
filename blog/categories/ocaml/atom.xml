<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Ocaml | My Little Garden of Code]]></title>
  <link href="http://philtomson.github.io/blog/categories/ocaml/atom.xml" rel="self"/>
  <link href="http://philtomson.github.io/"/>
  <updated>2017-02-02T17:21:37-08:00</updated>
  <id>http://philtomson.github.io/</id>
  <author>
    <name><![CDATA[Phil Tomson]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Comparing a Machine Learning Algorithm Implemented in F# and OCaml]]></title>
    <link href="http://philtomson.github.io/blog/2014/05/29/comparing-a-machine-learning-algorithm-implemented-in-f-number-and-ocaml/"/>
    <updated>2014-05-29T18:30:00-07:00</updated>
    <id>http://philtomson.github.io/blog/2014/05/29/comparing-a-machine-learning-algorithm-implemented-in-f-number-and-ocaml</id>
    <content type="html"><![CDATA[<p>(UPDATE: please see the <a href="http://philtomson.github.io/blog/2014/05/30/stop-the-presses-ocaml-wins/">next post: Stop the Presses: OCaml wins in terms of speed</a> in which it is shown that there were some serious flaws in my OCaml implementation below. I&rsquo;ll keep this post around for reference.)</p>

<p>I&rsquo;ve been dabbling with OCaml for the last several years and so when I saw a recent Meetup notice about an F# machine learning code dojo being led by <a href="https://github.com/mathias-brandewinder">Mathias Brandewinder</a> within walking distance of my house I thought I&rsquo;d check it out. I&rsquo;m one of those Linux guys who tends to eschew IDEs, prefers to use vim, and considers .NET to be some very foreign territory. F# is based on OCaml, so I figured I&rsquo;d have a bit of a headstart in the language area even if I haven&rsquo;t done any .NET development.</p>

<p>Also, I was curious as I had been hearing rumors on twitter that F# programs were running on Mono faster than the equivalent OCaml versions.  I was also taking Andrew Ng&rsquo;s Coursera Machine Learning course so the timing seemed good. So I loaded up <a href="http://www.mono-project.com/Main_Page">mono</a>, <a href="http://monodevelop.com/">monodevelop</a> and F#. As it turns out none of it worked on the day of the dojo, so I looked on with someone with a Windows laptop and Visual Studio.</p>

<p>The code dojo itself was a great way of learning F#. Check out Mathias' <a href="https://github.com/c4fsharp/Dojo-Digits-Recognizer">Digits Recognizer code Dojo code and instructions</a> which in turn was based on <a href="http://www.kaggle.com/c/digit-recognizer">a Kaggle Machine Learning challenge</a>.
The task was to implement a <a href="http://en.wikipedia.org/wiki/K-nearest_neighbors_algorithm">k-NN</a> (K Nearest Neighbor; in this case K=1) algorithm for recognizing handwritten digits from a dataset that was provided: A training set of 5000 labeled examples and a validation set of 500 labeled examples. Each digit example is a set of 28X28 grayscale pixels (784 integer values from 0 to 255).
We wrote a classifier that reads in the training set and then compares each of the 500 validation samples against those 5000 training exmples and returns the label associated with the closest match (the vector with the shortest distance from a training example). k-NN is one of the simplest machine learning algorithms, even so, we were able to get a 94.4% accuracy rate.</p>

<p>After the Dojo, I spent some time getting Monodevelop and F# running on my Ubuntu 12.04 laptop. Turns out I needed to get Monodevelop 4.0 (built from source) and F# 3.0 (initially tried F# 3.1, but Monodevelop 4.0 wasn&rsquo;t happy with that version). Then I set about reimplementing the algorithm in F# and after I got that working I reimplemented the same algorithm in OCaml.</p>

<p>Here&rsquo;s my F# implementation:</p>

<p><figure class='code'><figcaption><span>[ ] [title: ClassifyDigits.fs] </span></figcaption>
<div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
<span class='line-number'>50</span>
<span class='line-number'>51</span>
<span class='line-number'>52</span>
<span class='line-number'>53</span>
<span class='line-number'>54</span>
<span class='line-number'>55</span>
<span class='line-number'>56</span>
<span class='line-number'>57</span>
<span class='line-number'>58</span>
</pre></td><td class='code'><pre><code class='fsharp'><span class='line'><span class="k">module</span> <span class="nn">classifyDigits.Main</span><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span><span class="k">open</span> <span class="nn">System</span>
</span><span class='line'><span class="k">open</span> <span class="nn">System.IO</span><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span><span class="k">type</span> <span class="nc">LabelPixels</span> <span class="o">=</span> <span class="o">{</span> <span class="n">Label</span><span class="o">:</span> <span class="n">int</span><span class="o">;</span> <span class="n">Pixels</span><span class="o">:</span> <span class="n">int</span><span class="bp">[]</span> <span class="o">}</span>
</span><span class='line'><span class="k">let</span> <span class="nv">slurp_file</span> <span class="n">file</span> <span class="o">=</span>
</span><span class='line'>   <span class="nn">File</span><span class="p">.</span><span class="n">ReadAllLines</span><span class="o">(</span><span class="n">file</span><span class="o">).[</span><span class="mi">1</span><span class="o">..]</span>
</span><span class='line'>   <span class="o">|&gt;</span> <span class="nn">Array</span><span class="p">.</span><span class="n">map</span> <span class="o">(</span><span class="k">fun</span> <span class="n">line</span> <span class="o">-&gt;</span> <span class="n">line</span><span class="o">.</span><span class="n">Split</span><span class="o">(&amp;</span><span class="n">lsquo</span><span class="o">;,&amp;</span><span class="n">rsquo</span><span class="o">;))&lt;</span><span class="n">br</span><span class="o">/&gt;</span>
</span><span class='line'>   <span class="o">|&gt;</span> <span class="nn">Array</span><span class="p">.</span><span class="n">map</span> <span class="o">(</span><span class="k">fun</span> <span class="n">numline</span> <span class="o">-&gt;</span> <span class="nn">Array</span><span class="p">.</span><span class="n">map</span> <span class="o">(</span><span class="k">fun</span> <span class="o">(</span><span class="n">x</span><span class="o">:</span><span class="kt">string</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="nn">Convert</span><span class="p">.</span><span class="n">ToInt32</span><span class="o">(</span><span class="n">x</span><span class="o">))</span> <span class="n">numline</span><span class="o">)</span>  <span class="o">&lt;</span><span class="n">br</span><span class="o">/&gt;</span>
</span><span class='line'>   <span class="o">|&gt;</span> <span class="nn">Array</span><span class="p">.</span><span class="n">map</span> <span class="o">(</span><span class="k">fun</span> <span class="n">line</span> <span class="o">-&gt;</span> <span class="o">{</span> <span class="n">Label</span><span class="o">=</span> <span class="n">line</span><span class="o">.[</span><span class="mi">0</span><span class="o">];</span> <span class="n">Pixels</span><span class="o">=</span><span class="n">line</span><span class="o">.[</span><span class="mi">1</span><span class="o">..]</span> <span class="o">})&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span><span class="c1">//load the trainingsample&lt;br/&gt;</span>
</span><span class='line'><span class="k">let</span> <span class="nv">trainingset</span> <span class="o">=</span> <span class="n">slurp_file</span><span class="o">(&amp;</span><span class="n">ldquo</span><span class="o">;/</span><span class="n">home</span><span class="o">/</span><span class="n">phil</span><span class="o">/</span><span class="n">devel</span><span class="o">/</span><span class="n">f_sharp</span><span class="o">/</span><span class="n">Dojo</span><span class="o">-</span><span class="n">Digits</span><span class="o">-</span><span class="n">Recognizer</span><span class="o">/</span><span class="n">Dojo</span><span class="o">/</span><span class="n">trainingsample</span><span class="o">.</span><span class="n">csv</span><span class="o">&amp;</span><span class="n">rdquo</span><span class="o">;)&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span><span class="c1">//  COMPUTING DISTANCES&lt;/p&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span><span class="c1">// We need to compute the distance between images</span>
</span><span class='line'><span class="c1">// Math reminder: the euclidean distance is</span>
</span><span class='line'><span class="c1">// distance [ x1; y1; z1 ] [ x2; y2; z2 ] =</span>
</span><span class='line'><span class="c1">// sqrt((x1-x2)&lt;em&gt;(x1-x2) + (y1-y2)&lt;/em&gt;(y1-y2) + (z1-z2)*(z1-z2))&lt;/p&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span><span class="k">let</span> <span class="nv">distance</span> <span class="o">(</span><span class="n">p1</span><span class="o">:</span> <span class="n">int</span><span class="bp">[]</span><span class="o">)</span> <span class="o">(</span><span class="n">p2</span><span class="o">:</span> <span class="n">int</span><span class="bp">[]</span><span class="o">)</span> <span class="o">=</span>
</span><span class='line'>  <span class="nn">Math</span><span class="p">.</span><span class="n">Sqrt</span> <span class="o">(</span><span class="kt">float</span><span class="o">(</span><span class="nn">Array</span><span class="p">.</span><span class="n">sum</span> <span class="o">(</span><span class="nn">Array</span><span class="p">.</span><span class="n">map2</span> <span class="o">(</span> <span class="k">fun</span> <span class="n">a</span> <span class="n">b</span> <span class="o">-&gt;</span> <span class="o">(</span><span class="n">pown</span> <span class="o">(</span><span class="n">a</span><span class="o">-</span><span class="n">b</span><span class="o">)</span> <span class="mi">2</span><span class="o">))</span> <span class="n">p1</span> <span class="n">p2</span><span class="o">)</span> <span class="o">))&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span><span class="c1">//  WRITING THE CLASSIFIER FUNCTION&lt;/p&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span><span class="c1">// We are now ready to write a classifier function!</span>
</span><span class='line'><span class="c1">// The classifier should take a set of pixels</span>
</span><span class='line'><span class="c1">// (an array of ints) as an input, search for the</span>
</span><span class='line'><span class="c1">// closest example in our sample, and predict</span>
</span><span class='line'><span class="c1">// the value of that closest element.&lt;/p&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span><span class="k">let</span> <span class="nv">classify</span> <span class="o">(</span><span class="n">pixels</span><span class="o">:</span> <span class="n">int</span><span class="bp">[]</span><span class="o">)</span> <span class="o">=</span>
</span><span class='line'>  <span class="n">fst</span> <span class="o">(</span><span class="n">trainingset</span> <span class="o">|&gt;</span> <span class="nn">Array</span><span class="p">.</span><span class="n">map</span> <span class="o">(</span><span class="k">fun</span> <span class="n">x</span> <span class="o">-&gt;</span> <span class="o">(</span><span class="n">x</span><span class="o">.</span><span class="n">Label</span><span class="o">,</span> <span class="o">(</span><span class="n">distance</span> <span class="n">pixels</span> <span class="n">x</span><span class="o">.</span><span class="n">Pixels</span> <span class="o">)</span> <span class="o">))</span>
</span><span class='line'>                   <span class="o">|&gt;</span> <span class="nn">Array</span><span class="p">.</span><span class="n">minBy</span> <span class="o">(</span><span class="k">fun</span> <span class="n">x</span> <span class="o">-&gt;</span> <span class="n">snd</span> <span class="n">x</span> <span class="o">))&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span><span class="c1">// EVALUATING THE MODEL AGAINST VALIDATION DATA&lt;/p&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span><span class="c1">// Now that we have a classifier, we need to check</span>
</span><span class='line'><span class="c1">// how good it is.</span>
</span><span class='line'><span class="c1">// This is where the 2nd file, validationsample.csv,</span>
</span><span class='line'><span class="c1">// comes in handy.</span>
</span><span class='line'><span class="c1">// For each Example in the 2nd file,</span>
</span><span class='line'><span class="c1">// we know what the true Label is, so we can compare</span>
</span><span class='line'><span class="c1">// that value with what the classifier says.</span>
</span><span class='line'><span class="c1">// You could now check for each 500 example in that file</span>
</span><span class='line'><span class="c1">// whether your classifier returns the correct answer,</span>
</span><span class='line'><span class="c1">// and compute the % correctly predicted.&lt;/p&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span><span class="k">let</span> <span class="nv">_</span> <span class="o">=</span>
</span><span class='line'>    <span class="nn">Console</span><span class="p">.</span><span class="n">WriteLine</span><span class="o">(&amp;</span><span class="n">ldquo</span><span class="o">;</span><span class="n">start</span><span class="o">&amp;</span><span class="n">hellip</span><span class="o">;&amp;</span><span class="n">rdquo</span><span class="o">;)</span>
</span><span class='line'>    <span class="k">let</span> <span class="nv">validationsample</span> <span class="o">=</span> <span class="n">slurp_file</span><span class="o">(&amp;</span><span class="n">ldquo</span><span class="o">;/</span><span class="n">home</span><span class="o">/</span><span class="n">phil</span><span class="o">/</span><span class="n">devel</span><span class="o">/</span><span class="n">f_sharp</span><span class="o">/</span><span class="n">Dojo</span><span class="o">-</span><span class="n">Digits</span><span class="o">-</span><span class="n">Recognizer</span><span class="o">/</span><span class="n">Dojo</span><span class="o">/</span><span class="n">validationsample</span><span class="o">.</span><span class="n">csv</span><span class="o">&amp;</span><span class="n">rdquo</span><span class="o">;)</span>
</span><span class='line'>    <span class="k">let</span> <span class="nv">num_correct</span> <span class="o">=</span> <span class="o">(</span><span class="n">validationsample</span> <span class="o">|&gt;</span> <span class="nn">Array</span><span class="p">.</span><span class="n">map</span> <span class="o">(</span><span class="k">fun</span> <span class="n">p</span> <span class="o">-&gt;</span> <span class="k">if</span> <span class="o">(</span><span class="n">classify</span> <span class="n">p</span><span class="o">.</span><span class="n">Pixels</span> <span class="o">)</span> <span class="o">=</span> <span class="n">p</span><span class="o">.</span><span class="n">Label</span> <span class="k">then</span> <span class="mi">1</span> <span class="k">else</span> <span class="mi">0</span><span class="o">)</span>
</span><span class='line'>                                        <span class="o">|&gt;</span> <span class="nn">Array</span><span class="p">.</span><span class="n">sum</span><span class="o">)</span>
</span><span class='line'>    <span class="nn">Printf</span><span class="p">.</span><span class="n">printf</span> <span class="o">&amp;</span><span class="n">ldquo</span><span class="o">;</span><span class="n">Percentage</span> <span class="n">correct</span><span class="o">:%</span><span class="n">f</span><span class="err">\</span><span class="n">n</span><span class="o">&amp;</span><span class="n">rdquo</span><span class="o">;</span> <span class="o">((</span><span class="kt">float</span><span class="o">(</span><span class="n">num_correct</span><span class="o">)/</span> <span class="o">(</span><span class="kt">float</span><span class="o">(</span><span class="nn">Array</span><span class="p">.</span><span class="n">length</span> <span class="n">validationsample</span><span class="o">)))*</span><span class="mi">100</span><span class="o">.</span><span class="mi">0</span><span class="o">)&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span>
</span></code></pre></td></tr></table></div></figure></p>

<p>Timing when running this on my Dell XPS 13 (i7 Haswell, 8GB RAM):</p>

<pre><code>real        0m22.180s
user        0m22.253s
sys         0m0.116s
</code></pre>

<p>And the OCaml implementation:</p>

<p><figure class='code'><figcaption><span>[ ] [title: classifyDigits.ml] </span></figcaption>
<div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
<span class='line-number'>50</span>
<span class='line-number'>51</span>
<span class='line-number'>52</span>
<span class='line-number'>53</span>
<span class='line-number'>54</span>
<span class='line-number'>55</span>
<span class='line-number'>56</span>
<span class='line-number'>57</span>
<span class='line-number'>58</span>
<span class='line-number'>59</span>
<span class='line-number'>60</span>
<span class='line-number'>61</span>
<span class='line-number'>62</span>
<span class='line-number'>63</span>
<span class='line-number'>64</span>
<span class='line-number'>65</span>
<span class='line-number'>66</span>
<span class='line-number'>67</span>
<span class='line-number'>68</span>
<span class='line-number'>69</span>
<span class='line-number'>70</span>
<span class='line-number'>71</span>
<span class='line-number'>72</span>
<span class='line-number'>73</span>
<span class='line-number'>74</span>
<span class='line-number'>75</span>
</pre></td><td class='code'><pre><code class='ocaml'><span class='line'><span class="o">(&lt;</span><span class="n">em</span><span class="o">&gt;</span> <span class="nc">OCaml</span> <span class="n">version</span>
</span><span class='line'>   <span class="n">compile</span> <span class="k">with</span><span class="o">:</span>
</span><span class='line'>    <span class="n">ocamlopt</span> <span class="n">str</span><span class="o">.</span><span class="n">cmxa</span> <span class="o">-</span><span class="n">o</span> <span class="n">classifyDigits</span> <span class="n">classifyDigits</span><span class="o">.</span><span class="n">ml</span>
</span><span class='line'><span class="o">&lt;/</span><span class="n">em</span><span class="o">&gt;)&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span><span class="k">let</span> <span class="n">read_lines</span> <span class="n">name</span> <span class="o">:</span> <span class="kt">string</span> <span class="kt">list</span> <span class="o">=</span>
</span><span class='line'>  <span class="k">let</span> <span class="n">ic</span> <span class="o">=</span> <span class="n">open_in</span> <span class="n">name</span> <span class="k">in</span>
</span><span class='line'>  <span class="k">let</span> <span class="n">try_read</span> <span class="bp">()</span> <span class="o">=</span>
</span><span class='line'>    <span class="k">try</span> <span class="nc">Some</span> <span class="o">(</span><span class="n">input_line</span> <span class="n">ic</span><span class="o">)</span> <span class="k">with</span> <span class="nc">End_of_file</span> <span class="o">-&gt;</span> <span class="nc">None</span> <span class="k">in</span>
</span><span class='line'>  <span class="k">let</span> <span class="k">rec</span> <span class="n">loop</span> <span class="n">acc</span> <span class="o">=</span> <span class="k">match</span> <span class="n">try_read</span> <span class="bp">()</span> <span class="k">with</span>
</span><span class='line'>    <span class="o">|</span> <span class="nc">Some</span> <span class="n">s</span> <span class="o">-&gt;</span> <span class="n">loop</span> <span class="o">(</span><span class="n">s</span> <span class="o">::</span> <span class="n">acc</span><span class="o">)</span>
</span><span class='line'>    <span class="o">|</span> <span class="nc">None</span> <span class="o">-&gt;</span> <span class="n">close_in</span> <span class="n">ic</span><span class="o">;</span> <span class="nn">List</span><span class="p">.</span><span class="n">rev</span> <span class="n">acc</span> <span class="k">in</span>
</span><span class='line'>  <span class="n">loop</span> <span class="bp">[]</span><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span><span class="k">type</span> <span class="n">labelPixels</span> <span class="o">=</span> <span class="o">{</span> <span class="n">label</span><span class="o">:</span> <span class="kt">int</span><span class="o">;</span> <span class="n">pixels</span><span class="o">:</span> <span class="kt">int</span> <span class="kt">list</span> <span class="o">}</span>
</span><span class='line'><span class="k">let</span> <span class="n">slurp_file</span> <span class="n">file</span> <span class="o">=</span>
</span><span class='line'>   <span class="nn">List</span><span class="p">.</span><span class="n">tl</span> <span class="o">(</span><span class="n">read_lines</span> <span class="n">file</span><span class="o">)</span>
</span><span class='line'>   <span class="o">|&gt;</span> <span class="nn">List</span><span class="p">.</span><span class="n">map</span> <span class="o">(</span><span class="k">fun</span> <span class="n">line</span> <span class="o">-&gt;</span> <span class="nn">Str</span><span class="p">.</span><span class="n">split</span> <span class="o">(</span><span class="nn">Str</span><span class="p">.</span><span class="n">regexp</span> <span class="o">&amp;</span><span class="n">ldquo</span><span class="o">;,&amp;</span><span class="n">rdquo</span><span class="o">;)</span> <span class="n">line</span> <span class="o">)&lt;</span><span class="n">br</span><span class="o">/&gt;</span>
</span><span class='line'>   <span class="o">|&gt;</span> <span class="nn">List</span><span class="p">.</span><span class="n">map</span> <span class="o">(</span><span class="k">fun</span> <span class="n">numline</span> <span class="o">-&gt;</span> <span class="nn">List</span><span class="p">.</span><span class="n">map</span> <span class="o">(</span><span class="k">fun</span> <span class="o">(</span><span class="n">x</span><span class="o">:</span><span class="kt">string</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="n">int_of_string</span> <span class="n">x</span><span class="o">)</span> <span class="n">numline</span><span class="o">)</span>  <span class="o">&lt;</span><span class="n">br</span><span class="o">/&gt;</span>
</span><span class='line'>   <span class="o">|&gt;</span> <span class="nn">List</span><span class="p">.</span><span class="n">map</span> <span class="o">(</span><span class="k">fun</span> <span class="n">line</span> <span class="o">-&gt;</span> <span class="o">{</span> <span class="n">label</span><span class="o">=</span> <span class="o">(</span><span class="nn">List</span><span class="p">.</span><span class="n">hd</span> <span class="n">line</span><span class="o">);</span> <span class="n">pixels</span><span class="o">=(</span><span class="nn">List</span><span class="p">.</span><span class="n">tl</span> <span class="n">line</span><span class="o">)</span> <span class="o">})&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span><span class="k">let</span> <span class="n">trainingset</span> <span class="o">=</span> <span class="n">slurp_file</span><span class="o">(&amp;</span><span class="n">ldquo</span><span class="o">;./</span><span class="n">trainingsample</span><span class="o">.</span><span class="n">csv</span><span class="o">&amp;</span><span class="n">rdquo</span><span class="o">;)&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span><span class="c">(*</span>
</span><span class='line'><span class="c">// COMPUTING DISTANCES&lt;/p&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="c">&lt;p&gt;// We need to compute the distance between images</span>
</span><span class='line'><span class="c">// Math reminder: the euclidean distance is</span>
</span><span class='line'><span class="c">// distance [ x1; y1; z1 ] [ x2; y2; z2 ] =</span>
</span><span class='line'><span class="c">// sqrt((x1-x2)&lt;em&gt;(x1-x2) + (y1-y2)&lt;/em&gt;(y1-y2) + (z1-z2)&lt;em&gt;(z1-z2))</span>
</span><span class='line'><span class="c">&lt;/em&gt;)&lt;/p&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="c">&lt;p&gt;let list_sum lst = List.fold_left (fun x acc -&gt; x+.acc) 0.0 lst&lt;/p&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="c">&lt;p&gt;let distance (p1: int list) (p2: int list) =</span>
</span><span class='line'><span class="c">  sqrt (list_sum (List.map2 ( fun a b -&gt; (float_of_int(a-b)**2.0)) p1 p2) )&lt;/p&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="c">&lt;p&gt;(*</span>
</span><span class='line'><span class="c">// WRITING THE CLASSIFIER FUNCTION&lt;/p&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="c">&lt;p&gt;// We are now ready to write a classifier function!</span>
</span><span class='line'><span class="c">// The classifier should take a set of pixels</span>
</span><span class='line'><span class="c">// (an array of ints) as an input, search for the</span>
</span><span class='line'><span class="c">// closest example in our sample, and predict</span>
</span><span class='line'><span class="c">// the value of that closest element.</span>
</span><span class='line'><span class="c">*)&lt;/p&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="c">&lt;p&gt;let minBy f lst  =</span>
</span><span class='line'><span class="c">  let smallest = ref (List.hd lst) in</span>
</span><span class='line'><span class="c">  List.iter (fun x -&gt; if (f x) &amp;lt; (f !smallest) then smallest := x</span>
</span><span class='line'><span class="c">                          ) (List.tl lst) ;</span>
</span><span class='line'><span class="c">  !smallest ;;&lt;/p&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="c">&lt;p&gt;let classify (pixels: int list) =</span>
</span><span class='line'><span class="c">  fst ((List.map (fun (x: labelPixels) -&gt; (x.label, (distance pixels x.pixels) )) trainingset)</span>
</span><span class='line'><span class="c">       |&gt; minBy (fun x  -&gt; snd x)  )&lt;/p&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="c">&lt;p&gt;(*</span>
</span><span class='line'><span class="c">// EVALUATING THE MODEL AGAINST VALIDATION DATA&lt;/p&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="c">&lt;p&gt;// Now that we have a classifier, we need to check</span>
</span><span class='line'><span class="c">// how good it is.</span>
</span><span class='line'><span class="c">// This is where the 2nd file, validationsample.csv,</span>
</span><span class='line'><span class="c">// comes in handy.</span>
</span><span class='line'><span class="c">// For each Example in the 2nd file,</span>
</span><span class='line'><span class="c">// we know what the true Label is, so we can compare</span>
</span><span class='line'><span class="c">// that value with what the classifier says.</span>
</span><span class='line'><span class="c">// You could now check for each 500 example in that file</span>
</span><span class='line'><span class="c">// whether your classifier returns the correct answer,</span>
</span><span class='line'><span class="c">// and compute the % correctly predicted.</span>
</span><span class='line'><span class="c">*)&lt;/p&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="c">&lt;p&gt;let validationsample = slurp_file(&amp;ldquo;./validationsample.csv&amp;rdquo;)</span>
</span><span class='line'><span class="c">let num_correct = (validationsample |&gt; List.map (fun p -&gt; if (classify p.pixels ) = p.label then 1. else 0.) |&gt; list_sum)</span>
</span><span class='line'><span class="c">let _ = Printf.printf &amp;ldquo;Percentage correct:%f\n&amp;rdquo; (((num_correct)/. (float_of_int(List.length validationsample)))*.100.0)</span>
</span></code></pre></td></tr></table></div></figure></p>

<p>The code is very similar. The OCaml version is a bit longer because I needed to implement some functions that are built into the F# library, specifically, <em>minBy</em> (<em>Array.minBy</em> is built in to thd F# standard lib), <em>list_sum</em> (<em>Array.sum</em> is the F# builtin function) and <em>read_lines</em> (<em>File.ReadAllLines</em> is the F# builtin). One difference that could possibly effect performance: The F# version reads the data into <em>Array</em>s whereas the OCaml version reads the data into <em>List</em>s. The OCaml version was just easier to read into a <em>List</em> and OCaml&rsquo;s <em>List</em> module has a <em>map2</em> function whereas OCaml&rsquo;s <em>Array</em> module does not (F# apparently has a <em>map2</em> for both <em>Array</em> and <em>List</em>).</p>

<p>(EDIT: But as it turns out, using a List here instead of an Array is probably responsible for about &frac12; of the performance difference between the F# and the OCaml version. See <a href="(http://philtomson.github.io/blog/2014/05/30/stop-the-presses-ocaml-wins/">the update</a> )</p>

<p>I was surprised how much less performant the OCaml version was:</p>

<pre><code>real    0m47.311s
user    0m46.881s
sys     0m0.135s
</code></pre>

<p>The F# implementation was slightly more than twice as fast o_O.</p>

<p>Next, I recalled from the dojo that it&rsquo;s very easy to parallelize the maps in F#; instead of <em>Array.map</em> you use <em>Array.parallel.map</em>. So after a couple of edits to add parallel maps, I rebuilt and ran with the following time:</p>

<pre><code>real    0m16.400s
user    0m47.135s
sys     0m0.240s
</code></pre>

<p>So after that very simple change the F# version was very nearly 3X faster than the OCaml version. And in <em>top</em> I could see that the CPU usage was up to 360% as it ran.</p>

<p>Ah, but what about OCaml&rsquo;s <a href="https://github.com/rdicosmo/parmap">Parmap</a>?
I modified my OCaml version to use Parmap&hellip; but it took a lot longer to get it working than parallelizing the F# version. Probably about 30 minutes by the time I got it figured out (including figuring out how to compile it).</p>

<p>Here&rsquo;s the OCaml version of the <em>classify</em> function and <em>num_correct</em> that uses Parmap:</p>

<p><figure class='code'><figcaption><span>[ ] [title: classifyDigitsPar.ml] </span></figcaption>
<div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class='ocaml'><span class='line'><span class="k">let</span> <span class="n">classify</span> <span class="o">(</span><span class="n">pixels</span><span class="o">:</span> <span class="kt">int</span> <span class="kt">list</span><span class="o">)</span> <span class="o">=</span>
</span><span class='line'>  <span class="k">let</span> <span class="n">label_dist</span> <span class="o">=</span> <span class="nn">Parmap</span><span class="p">.</span><span class="n">parmap</span> <span class="o">~</span><span class="n">chunksize</span><span class="o">:</span><span class="mi">50</span> <span class="o">~</span><span class="n">ncores</span><span class="o">:</span><span class="mi">4</span> <span class="o">(</span><span class="k">fun</span> <span class="n">x</span> <span class="o">-&gt;</span> <span class="o">(</span><span class="n">x</span><span class="o">.</span><span class="n">label</span><span class="o">,</span> <span class="o">(</span><span class="n">distance</span> <span class="n">pixels</span> <span class="n">x</span><span class="o">.</span><span class="n">pixels</span><span class="o">)</span> <span class="o">))</span> <span class="o">(</span><span class="nn">Parmap</span><span class="p">.</span><span class="nc">L</span> <span class="n">trainingset</span><span class="o">)</span> <span class="k">in</span>
</span><span class='line'>  <span class="k">let</span> <span class="n">min</span> <span class="o">=</span> <span class="n">minBy</span> <span class="o">(</span><span class="k">fun</span> <span class="n">x</span> <span class="n">y</span> <span class="o">-&gt;</span> <span class="n">compare</span> <span class="o">(</span><span class="n">snd</span> <span class="n">x</span><span class="o">)</span> <span class="o">(</span><span class="n">snd</span> <span class="n">y</span><span class="o">))</span> <span class="n">label_dist</span> <span class="k">in</span>
</span><span class='line'>  <span class="n">fst</span> <span class="n">min</span><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span><span class="k">let</span> <span class="n">num_correct</span> <span class="o">=</span>
</span><span class='line'>  <span class="o">(</span><span class="nn">Parmap</span><span class="p">.</span><span class="nc">L</span> <span class="n">validationsample</span><span class="o">)</span> <span class="o">|&gt;</span> <span class="nn">Parmap</span><span class="p">.</span><span class="n">parmap</span> <span class="o">~</span><span class="n">ncores</span><span class="o">:</span><span class="mi">4</span> <span class="o">(</span><span class="k">fun</span> <span class="n">p</span> <span class="o">-&gt;</span> <span class="k">if</span> <span class="o">(</span><span class="n">classify</span> <span class="n">p</span><span class="o">.</span><span class="n">pixels</span> <span class="o">)</span> <span class="o">=</span> <span class="n">p</span><span class="o">.</span><span class="n">label</span> <span class="k">then</span> <span class="mi">1</span><span class="o">.</span> <span class="k">else</span> <span class="mi">0</span><span class="o">.)</span> <span class="o">|&gt;</span> <span class="n">list_sum</span>
</span></code></pre></td></tr></table></div></figure></p>

<p>Notice that you have to tell it how many cores you have.</p>

<p>After I got it to compile I ran it with much anticipation&hellip;</p>

<pre><code>real    1m43.140s
user    5m38.809s
sys     0m42.811s
</code></pre>

<p>&hellip; over twice as slow as the original OCaml implementation.
I noticed in <em>top</em> that this version launched 4 different <em>classifyDigitPar</em> processes so I&rsquo;m guessing that it uses sockets to communicate between the processes. For this particular problem that doesn&rsquo;t appear to be effective. Perhaps it would be for a longer running example, but I&rsquo;m not sure. F# certainly wins in the parallelization department.</p>

<h3>Observations</h3>

<p>Other than performance (where F# on Mono seems to win handily) I noticed the following:</p>

<ol>
<li>The Array slicing syntax in F# is quite nice.</li>
<li>F#&rsquo;s standard library is just more comprehensive. I could have probably used Janestreet&rsquo;s <em>Core</em> library for OCaml which is quite comprehensive, but I wanted to stick with the standard library for both.</li>
<li>Monodevelop has a <em>vi</em> editing mode. It&rsquo;s kind of ok. But it&rsquo;s missing a lot of keybindings that you&rsquo;d have in native vi.</li>
<li>I have no idea what F#&rsquo;s (or Monodevelop&rsquo;s) equavilent to <em>opam</em> is. I&rsquo;m guessing OCaml wins in the package management department.</li>
<li>F#&rsquo;s polymorphic math operators were nice (no need for <em>+.</em>, etc.).</li>
</ol>


<p>You can find the code above in <a href="https://github.com/philtomson/ClassifyDigits">my github</a></p>

<h3>Next Time</h3>

<p>I want to implement the algorithm in <a href="http://julialang.org/">Julia</a>. I&rsquo;m going to guess that Julia&rsquo;s vectorization support means that it will beat both OCaml and F#.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Coding Happy Little Trees: Tree Meditation #1]]></title>
    <link href="http://philtomson.github.io/blog/2014/04/29/coding-pretty-little-trees-tree-meditation-number-1/"/>
    <updated>2014-04-29T12:33:00-07:00</updated>
    <id>http://philtomson.github.io/blog/2014/04/29/coding-pretty-little-trees-tree-meditation-number-1</id>
    <content type="html"><![CDATA[<p><img src="http://t3.gstatic.com/images?q=tbn:ANd9GcSIjEBactvxvvUkh6DVgHT2Dan9e57x3nbGbq5RdzjwXkcV4V1r" title="Bob Ross, master of happy trees" alt="Alt Bob Ross" /></p>

<p><em>It all started a few months ago when I created a quad-tree structure and
then wanted to be able to visualize those trees with GraphViz. Thus
  this tree meditation was born. And who was the master of happy little trees? <a href="http://en.wikipedia.org/wiki/Bob_Ross">Bob Ross</a> of course. So if you like, read the following in Bob&rsquo;s very relaxing voice&hellip;. try not to go to sleep.</em></p>

<p>Before we can code our happy little trees we need to define what a tree is:</p>

<p><figure class='code'><figcaption><span>[ ] [title: binary tree type in OCaml] </span></figcaption>
<div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='ocaml'><span class='line'><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">h1</span><span class="o">&gt;</span><span class="k">type</span> <span class="o">&amp;</span><span class="n">lsquo</span><span class="o">;</span><span class="n">a</span> <span class="n">tree</span> <span class="o">=</span> <span class="nc">Empty</span> <span class="o">|</span> <span class="nc">Leaf</span> <span class="k">of</span> <span class="k">&#39;</span><span class="n">a</span> <span class="o">|</span> <span class="nc">Node</span> <span class="k">of</span> <span class="k">&#39;</span><span class="n">a</span> <span class="n">tree</span> <span class="o">*</span> <span class="k">&#39;</span><span class="n">a</span> <span class="o">*</span> <span class="k">&#39;</span><span class="n">a</span> <span class="n">tree</span> <span class="o">;;&lt;/</span><span class="n">h1</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span>
</span></code></pre></td></tr></table></div></figure></p>

<p>You can go ahead and type that yourself into the <a href="http://try.ocamlpro.com/">online OCaml REPL (Read Evaluate Print Loop)</a>. Go ahead, give it a try.</p>

<p>The type definition here is in <a href="http://ocaml.org/">OCaml</a>. The ML family of languages (SML, OCaml and Haskell, for example) excel at creating pretty trees because they have <a href="http://en.wikipedia.org/wiki/Algebraic_data_type">algebraic data types</a>. What&rsquo;s the <em>&lsquo;a tree</em> mean? The <em>'a</em> is a type variable and means that we&rsquo;re creating trees which contain data of type <em>'a</em>. Since <em>'a</em> isn&rsquo;t specified it means that any type of data could live in the tree; our tree is <em>polymorphic</em>.</p>

<p>Since this is a SUM type (also called an OR type, notice the &lsquo;|&rsquo;s in the definition above) we can surmise that a tree can either be <em>Empty</em> or have a <em>Leaf</em> or a <em>Node</em>. <em>Empty</em>, <em>Leaf</em> and <em>Node</em> are used to build our tree, they are our tree <em>constructors</em>.</p>

<p><em>Empty</em>, what&rsquo;s that mean? Think of it as the tree of nothingness. Very Zen. Hopefully it will make more sense when we start creating and traversing trees.</p>

<p><em>Leaf of &lsquo;a</em> means that a leaf can contain data of type <em>'a</em> and as was explained above, that means that the leaf can contain data of any type. How do we create a <em>Leaf of 'a</em> in our code?</p>

<p><figure class='code'><figcaption><span>[ ] [title: How to make a leaf] </span></figcaption>
<div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='ocaml'><span class='line'><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">h1</span><span class="o">&gt;</span><span class="nc">Leaf</span> <span class="o">&amp;</span><span class="n">ldquo</span><span class="o">;</span><span class="nc">I</span><span class="o">&amp;</span><span class="n">rsquo</span><span class="o">;</span><span class="n">m</span> <span class="n">a</span> <span class="nc">Leaf</span><span class="o">&amp;</span><span class="n">rdquo</span><span class="o">;</span> <span class="o">;;&lt;/</span><span class="n">h1</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">ul</span><span class="o">&gt;</span>
</span><span class='line'><span class="o">&lt;</span><span class="n">li</span><span class="o">&gt;:</span> <span class="kt">string</span> <span class="n">tree</span> <span class="o">=</span> <span class="nc">Leaf</span> <span class="o">&amp;</span><span class="n">ldquo</span><span class="o">;</span><span class="nc">I</span><span class="o">&amp;</span><span class="n">rsquo</span><span class="o">;</span><span class="n">m</span> <span class="n">a</span> <span class="nc">Leaf</span><span class="o">&amp;</span><span class="n">rdquo</span><span class="o">;</span>
</span></code></pre></td></tr></table></div></figure></li>
</ul>


<p>The above was typed into the OCaml REPL. The <em>#</em> is the REPL prompt, we only typed in the actual <em>Leaf &ldquo;I&rsquo;m a Leaf&rdquo;</em> part. The second line shows the result. Notce that the type is <em>string tree</em> because we passed a string to the <em>Leaf</em> constructor. So our leaf is itself a tree. Ok, maybe that seems a little stange, but hold up a leaf by the stem and it can certainly look like a little tree on it&rsquo;s own, don&rsquo;t you think? Fractals, think fractals.</p>

<p>Now we&rsquo;re left with that <em>Node of &lsquo;a tree * 'a * 'a tree</em> part of the tree type definition. Here we&rsquo;ve reached the essence of <em>treeness</em>. A <em>Node</em> of a tree has three parts: A <em>'a tree</em> on the left, the actual <em>'a</em> data contained by this <em>Node</em> and another <em>'a tree</em> on the right. This part of the definition of <em>tree</em> is recursive because a <em>Node</em> is the piece of a tree which can contain other trees - in our case we have defined a <em>binary</em> tree type since each node has only two branches: a left tree and a right tree. What&rsquo;s with the asterisks? Technically they indicate that this part of the type is a <em>Cartesian product</em> (algebraic datatypes remember). We can think of this particular one as a <em>triple</em> - a collection of 3 things.</p>

<p>So without further ado, let&rsquo;s code a happy little tree:</p>

<p><figure class='code'><figcaption><span>[ ] [title: Our first happy little tree ] </span></figcaption>
<div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='ocaml'><span class='line'><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">h1</span><span class="o">&gt;</span><span class="nc">Node</span><span class="o">(</span><span class="nc">Leaf</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="nc">Leaf</span> <span class="mi">3</span><span class="o">)</span> <span class="o">;;&lt;/</span><span class="n">h1</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">ul</span><span class="o">&gt;</span>
</span><span class='line'><span class="o">&lt;</span><span class="n">li</span><span class="o">&gt;:</span> <span class="kt">int</span> <span class="n">tree</span> <span class="o">=</span> <span class="nc">Node</span> <span class="o">(</span><span class="nc">Leaf</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="nc">Leaf</span> <span class="mi">3</span><span class="o">)</span>
</span></code></pre></td></tr></table></div></figure></li>
</ul>


<p>The REPL tells us this is an <em>int tree</em>, a tree which contains integers at it&rsquo;s nodes and leaves.</p>

<p>And what does it look like?</p>

<p><img src="%20/images/happy_tree.png" alt="Alt Our Happy Tree" /></p>

<p>Notice in this case that we&rsquo;ve got a complete tree; we did not use the <em>Empty</em> constructor. What if we had?</p>

<p><figure class='code'><figcaption><span>[ ] [title: a perhaps less happy little tree ] </span></figcaption>
<div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='ocaml'><span class='line'><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">h1</span><span class="o">&gt;</span><span class="nc">Node</span><span class="o">(</span><span class="nc">Leaf</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="nc">Empty</span><span class="o">)</span> <span class="o">;;&lt;/</span><span class="n">h1</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">ul</span><span class="o">&gt;</span>
</span><span class='line'><span class="o">&lt;</span><span class="n">li</span><span class="o">&gt;:</span> <span class="kt">int</span> <span class="n">tree</span> <span class="o">=</span> <span class="nc">Node</span> <span class="o">(</span><span class="nc">Leaf</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="nc">Empty</span><span class="o">)</span>
</span></code></pre></td></tr></table></div></figure></li>
</ul>


<p>Now we have what is perhaps a less happy little tree. The right branch of our little tree is <em>empty</em>. The <em>Leaf 3</em> has fallen. Now perhaps you can see why we need <em>Empty</em>. <em>Node</em> must have two sub-trees. We can&rsquo;t just do something like:</p>

<p><figure class='code'><figcaption><span>[ ] [title: an erroneous tree ] </span></figcaption>
<div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class='ocaml'><span class='line'><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">h1</span><span class="o">&gt;</span><span class="nc">Node</span><span class="o">(</span><span class="nc">Leaf</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">1</span><span class="o">)</span> <span class="o">;;&lt;/</span><span class="n">h1</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span><span class="nc">File</span> <span class="o">&amp;</span><span class="n">ldquo</span><span class="o">;&amp;</span><span class="n">rdquo</span><span class="o">;,</span> <span class="n">line</span> <span class="mi">1</span><span class="o">,</span> <span class="n">characters</span> <span class="mi">1</span><span class="o">-</span><span class="mi">16</span><span class="o">:</span>
</span><span class='line'><span class="nc">Error</span><span class="o">:</span> <span class="nc">The</span> <span class="n">constructor</span> <span class="nc">Node</span> <span class="n">expects</span> <span class="mi">3</span> <span class="n">argument</span><span class="o">(</span><span class="n">s</span><span class="o">),</span>
</span><span class='line'>       <span class="n">but</span> <span class="n">is</span> <span class="n">applied</span> <span class="n">here</span> <span class="k">to</span> <span class="mi">2</span> <span class="n">argument</span><span class="o">(</span><span class="n">s</span><span class="o">)</span>
</span></code></pre></td></tr></table></div></figure></p>

<p>Because the <em>Node</em> constructor expects to have three components. So <em>Empty</em> is used to designate the absense of a <em>Node</em> or <em>Leaf</em>.</p>

<p>How did I draw that tree above? That&rsquo;ll have to wait for the next Tree Medititation installment when we&rsquo;ll discuss things like <em>tree traversal</em> and generating <em>dot files</em> used by <a href="http://www.graphviz.org/">Graphviz</a> to create images.</p>
]]></content>
  </entry>
  
</feed>
