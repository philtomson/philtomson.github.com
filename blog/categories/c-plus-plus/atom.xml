<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: C++ | My Little Garden of Code]]></title>
  <link href="http://philtomson.github.io/blog/categories/c-plus-plus/atom.xml" rel="self"/>
  <link href="http://philtomson.github.io/"/>
  <updated>2017-02-03T15:54:21-08:00</updated>
  <id>http://philtomson.github.io/</id>
  <author>
    <name><![CDATA[Phil Tomson]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[C++ Dusty Corner #5379: 0 Is Sometimes a Special Number]]></title>
    <link href="http://philtomson.github.io/blog/2014/03/07/c-plus-plus-dusty-corner-number-537-0-is-sometimes-a-special/"/>
    <updated>2014-03-07T08:57:00-08:00</updated>
    <id>http://philtomson.github.io/blog/2014/03/07/c-plus-plus-dusty-corner-number-537-0-is-sometimes-a-special</id>
    <content type="html"><![CDATA[<p>I recently discovered the <a href="http://cppquiz.org/">C++ Quiz site</a> and
figuring that it&rsquo;s always good to practice C++ skills I started going
through the questions. The third question I
encountered gave me some pause&hellip;  The question was:</p>

<pre><code>According to the C++11 standard, what is the output of this program?

#include &lt;iostream&gt;

void print(char const *str) { std::cout &lt;&lt; str; }
void print(short num) { std::cout &lt;&lt; num; }

int main() {
  print("abc");
  print(0);
  print('A');
}
</code></pre>

<p>Now the obvious response would be &ldquo;abc065&rdquo;, but I suspected there was some
sort of trickery afoot here. Finally, I just entered &ldquo;abc065&rdquo; and of course
my suspicion was right: the answer was incorrect. Then I went ahead and
&ldquo;cheated&rdquo; by pasting the code into a file and compiling it:</p>

<pre><code>$ g++ -o quiz1 quiz1.cpp
quiz1.cpp: In function ‘int main()’:
quiz1.cpp:9:10: error: call of overloaded ‘print(int)’ is ambiguous
print(0);
      ^
quiz1.cpp:9:10: note: candidates are:
quiz1.cpp:4:6: note: void print(const char*)
void print(char const *str) { std::cout &lt;&lt; str; }
quiz1.cpp:5:6: note: void print(short int)
void print(short num) { std::cout &lt;&lt; num; }
</code></pre>

<p><em>&ldquo;Umm&hellip; ok&rdquo;</em>, I thought <em>&ldquo;shouldn&rsquo;t the int literal 0 be cast to a short
automatically? What gives here?&rdquo;</em>. Maybe clang will give me a more
descriptive error message? It&rsquo;s known for that, right?</p>

<pre><code>$ clang++  -o quiz1 quiz1.cpp
quiz1.cpp:9:3: error: call to 'print' is ambiguous
print(0);
      ^~~~~
quiz1.cpp:4:6: note: candidate function
void print(char const *str) { std::cout &lt;&lt; str; }
quiz1.cpp:5:6: note: candidate function
void print(short num) { std::cout &lt;&lt; num; }
</code></pre>

<p>Ok, so clang didn&rsquo;t reveal any new information here&hellip; other than
those fancy tildas. So I went back to the CPP Quiz site and chose
&ldquo;has compilation error&rdquo; and clicked &lsquo;Answer&rsquo; to get the explanation:</p>

<pre><code>Sneaky ambiguous function call.

The statement print(0); is ambiguous due to overload resolution rules. 
Both print functions are viable, but for the compiler to pick one, 
one of them has to have a better conversion sequence than the other. 
§13.3.3¶2: "If there is exactly one viable function that is a better 
function than all other viable functions, then it is the one selected 
by overload resolution; otherwise the call is ill-formed".

(a) *Because 0 is a null pointer constant[1], it can be converted 
implicitly into any pointer type with a single conversion.*

(b) Because 0 is of type int, it can be converted implicitly to a 
short with a single conversion too.

In our case, both are standard conversion sequences with a single 
conversion of "conversion rank". Since no function is better than 
the other, the call is ill-formed.

[1] §4.10¶1 A null pointer constant is an integral constant expression 
(5.19) prvalue of integer type that evaluates to zero(...) A null 
pointer constant can be converted to a pointer type.
</code></pre>

<p>Ooookaaayy&hellip; so this is one of those occasions where being a C++ programmer
is very much akin to being a lawyer: you need to be up on all of the
provisos, caveats and special exemptions in the law (or in the spec in this
case).</p>

<p>So what happened? Passing &lsquo;0&rsquo; to the <em>print</em> function can interpretted as
either passing a null pointer to the first <em>print</em> function or as a short
0 to the second, overloaded <em>print</em> function. Ok, so couldn&rsquo;t any
integer being passed to the print function also be interpreted as possibly
being a pointer?  So as an experiment I changed:</p>

<pre><code>print(0);
</code></pre>

<p>To:
    print(2);</p>

<p>Of course, then it compiles just fine. So &lsquo;0&rsquo; is a <em>special</em> number in this
context because it&rsquo;s also the null pointer constant.</p>

<p>If you are a programming polyglot like me, your first reaction upon realizing
this is probably to want to run to the relative safety of gated communities
such as OCaml, Haskell or maybe Python where these kinds of incidents
just don&rsquo;t happen (because no pointers -> no NULL -> no special case for 0).
&hellip;until you realize that those neighborhoods have their own, different
quirks and in fact there&rsquo;s no perfect language (well, except for Lisp,
maybe, but <em>which Lisp?</em>).</p>

<p>Sometimes you&rsquo;ve gotta hang out in the C++ hood with all of the sirens
and gunshots in the background in order to get things done. As always, you
just need to be very wary while you&rsquo;re in the C++ hood in order to survive.
Fortunately, in this case it&rsquo;s just a compilation error that seems rather
confusing at first, not a segfault.</p>

<p>Sure it&rsquo;s definitely strange that 0 is a special case integer in this
context, but to be fair, how often would you actually run into this
situation in C++? I&rsquo;d guess it would be very rare. In most cases you
wouldn&rsquo;t be passing a &lsquo;0&rsquo; literal to a function like that - you&rsquo;d instead
be passing in a variable and even if that variable contains &lsquo;0&rsquo;, that&rsquo;s
just fine.</p>
]]></content>
  </entry>
  
</feed>
