
<!DOCTYPE html>
<!--[if IEMobile 7 ]><html class="no-js iem7"><![endif]-->
<!--[if lt IE 9]><html class="no-js lte-ie8"><![endif]-->
<!--[if (gt IE 8)|(gt IEMobile 7)|!(IEMobile)|!(IE)]><!--><html class="no-js" lang="en"><!--<![endif]-->
<head>
  <meta charset="utf-8">
  <title>Drawing Happy Little Trees: Tree Meditation #2 - My Little Garden of Code</title>
  <meta name="author" content="Phil Tomson">

  
  <meta name="description" content="In the previous Tree Meditation we pondered some preliminary ideas about treeness. Now let&rsquo;s think about how to draw our trees. Before we &hellip;">
  

  <!-- http://t.co/dKP3o1e -->
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  
  <link rel="canonical" href="http://philtomson.github.io/blog/2014/05/14/drawing-happy-little-trees-tree-meditation-number-2/">
  <link href="/favicon.png" rel="icon">
  <link href="/stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
  <link href="/atom.xml" rel="alternate" title="My Little Garden of Code" type="application/atom+xml">
  <script src="/javascripts/modernizr-2.0.js"></script>
  <script src="//ajax.googleapis.com/ajax/libs/jquery/1.9.1/jquery.min.js"></script>
  <script>!window.jQuery && document.write(unescape('%3Cscript src="/javascripts/libs/jquery.min.js"%3E%3C/script%3E'))</script>
  <script src="/javascripts/octopress.js" type="text/javascript"></script>
  <!--Fonts from Google"s Web font directory at http://google.com/webfonts -->
<link href="//fonts.googleapis.com/css?family=PT+Serif:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">
<link href="//fonts.googleapis.com/css?family=PT+Sans:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">

  

</head>

<body   >
  <header role="banner"><hgroup>
  <h1><a href="/">My Little Garden of Code</a></h1>
  
    <h2>bloggings about codings</h2>
  
</hgroup>

</header>
  <nav role="navigation"><ul class="subscription" data-subscription="rss">
  <li><a href="/atom.xml" rel="subscribe-rss" title="subscribe via RSS">RSS</a></li>
  
</ul>
  
<form action="https://www.google.com/search" method="get">
  <fieldset role="search">
    <input type="hidden" name="sitesearch" value="philtomson.github.io">
    <input class="search" type="text" name="q" results="0" placeholder="Search"/>
  </fieldset>
</form>
  
<ul class="main-navigation">
  <li><a href="/">Blog</a></li>
  <li><a href="/blog/archives">Archives</a></li>
</ul>

</nav>
  <div id="main">
    <div id="content">
      <div>
<article class="hentry" role="article">
  
  <header>
    
      <h1 class="entry-title">Drawing Happy Little Trees: Tree Meditation #2</h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2014-05-14T11:55:00-07:00'><span class='date'><span class='date-month'>May</span> <span class='date-day'>14</span><span class='date-suffix'>th</span>, <span class='date-year'>2014</span></span> <span class='time'>11:55 am</span></time>
        
           | <a href="#disqus_thread"
             data-disqus-identifier="http://philtomson.github.io">Comments</a>
        
      </p>
    
  </header>


<div class="entry-content"><p><img src="http://upload.wikimedia.org/wikipedia/commons/e/eb/Ash_Tree_-_geograph.org.uk_-_590710.jpg" alt="Alt Ash Tree" /></p>

<p><em>In the <a href="http://philtomson.github.io/blog/2014/04/29/coding-pretty-little-trees-tree-meditation-number-1/">previous Tree Meditation</a> we pondered some preliminary ideas about treeness. Now let&rsquo;s think about how to draw our trees. Before we start, make sure you paste this tree type code from the last installment into the <a href="http://try.ocamlpro.com/">Try OCaml REPL</a>:</em></p>

<figure class='code'><figcaption><span>[ ] [title: our tree type definition] </span></figcaption>
<div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='ocaml'><span class='line'><span class="k">type</span> <span class="k">&#39;</span><span class="n">a</span> <span class="n">tree</span> <span class="o">=</span> <span class="nc">Empty</span> <span class="o">|</span> <span class="nc">Leaf</span> <span class="k">of</span> <span class="k">&#39;</span><span class="n">a</span> <span class="o">|</span> <span class="nc">Node</span> <span class="k">of</span> <span class="k">&#39;</span><span class="n">a</span> <span class="n">tree</span> <span class="o">*</span> <span class="k">&#39;</span><span class="n">a</span> <span class="o">*</span> <span class="k">&#39;</span><span class="n">a</span> <span class="n">tree</span>
</span></code></pre></td></tr></table></div></figure>


<p>Last time we coded our little tree using the constructors <em>Empty</em>, <em>Leaf</em>, and <em>Node</em> defined in our tree type:</p>

<figure class='code'><figcaption><span>[ ] [title: Our first happy little tree ] </span></figcaption>
<div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='ocaml'><span class='line'><span class="nc">Node</span><span class="o">(</span><span class="nc">Leaf</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="nc">Leaf</span> <span class="mi">3</span><span class="o">)</span> <span class="o">;;</span>
</span><span class='line'><span class="o">-</span> <span class="o">:</span> <span class="kt">int</span> <span class="n">tree</span> <span class="o">=</span> <span class="nc">Node</span> <span class="o">(</span><span class="nc">Leaf</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="nc">Leaf</span> <span class="mi">3</span><span class="o">)</span>
</span></code></pre></td></tr></table></div></figure>


<p><em>NOTE: if you&rsquo;re using your own local OCaml REPL (ocaml or utop) make sure you terminate all of the entries here with double semicolon: ;;  The Try Ocaml REPL seems to do this for you automatically.</em></p>

<p>To create a picture of the tree we&rsquo;ll use <a href="http://www.graphviz.org/">Graphviz</a> which is a suite of commandline tools that can be used to visualize graphs. Since our tree is a <a href="http://en.wikipedia.org/wiki/Tree_(graph_theory)">graph</a>, we can use Graphviz to visualize it. Specifically, we&rsquo;ll use a program called <em>dot</em> to create a visual representation of the graph.</p>

<p>This is what our tree should look like in the <em>dot</em> language:</p>

<figure class='code'><figcaption><span>[ ] [title: tree.dot ] </span></figcaption>
<div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='ocaml'><span class='line'>  <span class="n">graph</span> <span class="n">tree</span> <span class="o">{</span>
</span><span class='line'>    <span class="o">{</span><span class="nc">N1</span><span class="o">[</span><span class="n">label</span><span class="o">=</span><span class="s2">&quot;1&quot;</span><span class="o">]}--</span> <span class="o">{</span><span class="nc">L2</span><span class="o">[</span><span class="n">shape</span><span class="o">=</span><span class="n">box</span><span class="o">,</span><span class="n">label</span><span class="o">=</span><span class="s2">&quot;2&quot;</span><span class="o">]}</span>
</span><span class='line'>    <span class="o">{</span><span class="nc">N1</span><span class="o">[</span><span class="n">label</span><span class="o">=</span><span class="s2">&quot;1&quot;</span><span class="o">]}--</span> <span class="o">{</span><span class="nc">L3</span><span class="o">[</span><span class="n">shape</span><span class="o">=</span><span class="n">box</span><span class="o">,</span><span class="n">label</span><span class="o">=</span><span class="s2">&quot;3&quot;</span><span class="o">]}</span>
</span><span class='line'>  <span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>We have a graph called <em>tree</em>. Inside of the <em>tree</em> block we define the connections between the nodes (or in our case between <em>Node</em>s and/or <em>Leaf</em>s, but no <em>Empty</em>s, of course, as they&rsquo;re invisible).</p>

<p>Each node in the graph needs a unique identifier which is what <em>N1,L2</em> and <em>L3</em> are above. We also give each node a label which is what is shown
in the graphical output of the tree. That&rsquo;s the <em>[label=&ldquo;some label&rdquo;]</em> part of the node specifications above.</p>

<p>The &lsquo;&ndash;&rsquo; means that there is a connection between two nodes.</p>

<p>It&rsquo;s a fairly simple representation of our tree. We can generate the picture of the tree by running:</p>

<pre><code>$ dot -Tsvg -o happy_tree.svg tree.dot
</code></pre>

<p>This will generate the file happy_tree.svg which we see here:</p>

<p><img src="/images/happy_tree.svg" alt="Alt Our Happy Tree" /></p>

<p>That&rsquo;s nice and all, but what if our tree is much larger than this one and has many nodes and leaves? We&rsquo;d like to be able to generate the <em>tree.dot</em> file automatically from our coded representation of our tree. To do that we need to talk a bit about tree <em>traversal</em> (visiting each node or leaf of our tree structure).</p>

<p>Let&rsquo;s create a somewhat bigger tree to make our traversal discussion clearer:</p>

<figure class='code'><figcaption><span>[ ] [title: bigger tree ] </span></figcaption>
<div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
</pre></td><td class='code'><pre><code class='ocaml'><span class='line'><span class="k">let</span> <span class="n">t</span> <span class="o">=</span> <span class="nc">Node</span> <span class="o">(</span>
</span><span class='line'>              <span class="nc">Node</span> <span class="o">(</span>
</span><span class='line'>                    <span class="nc">Leaf</span> <span class="s2">&quot;0&quot;</span><span class="o">,</span>
</span><span class='line'>                    <span class="s2">&quot;1&quot;</span><span class="o">,</span>
</span><span class='line'>                    <span class="nc">Leaf</span> <span class="s2">&quot;2&quot;</span><span class="o">),</span>
</span><span class='line'>              <span class="s2">&quot;3&quot;</span><span class="o">,</span>
</span><span class='line'>              <span class="nc">Node</span> <span class="o">(</span>
</span><span class='line'>                    <span class="nc">Leaf</span> <span class="s2">&quot;4&quot;</span><span class="o">,</span>
</span><span class='line'>                    <span class="s2">&quot;5&quot;</span><span class="o">,</span>
</span><span class='line'>                    <span class="nc">Leaf</span> <span class="s2">&quot;6&quot;</span>
</span><span class='line'>              <span class="o">)</span>
</span><span class='line'>         <span class="o">)</span>
</span></code></pre></td></tr></table></div></figure>


<p>Which looks like:</p>

<p><img src="/images/bigger_tree.svg" alt="Alt Our Happy Tree" /></p>

<p>So why the odd order of the numbers in the tree above? One thing that&rsquo;s not clear in our type definition from the previous article is that, by convention, an important property of binary trees is that child trees to the left of the current node should contain values that are less than the value held in the current node and child trees to the right of the current node should contain values that are greater than the value of the current node.</p>

<p>(As an aside, if we wanted to encode that requirement in our type definition we would need to be using a language which has <a href="http://en.wikipedia.org/wiki/Dependent_type"><em>dependent types</em></a> )</p>

<p>Our chosen ordering above will become clearer as we talk about different types of traversal.</p>

<h2>Tree Traversal</h2>

<p>In order to generate a dot file that represents our tree we&rsquo;ll need to <em>traverse</em> the nodes of our tree meaning we need to somehow visit all of the nodes of our tree structure.</p>

<p>There are two categories of tree traversal: <em>Depth First</em> or <em>Breadth First (aka Level Order Traversal)</em>.</p>

<p>In all cases we start the tree traversal from the root of the tree. In our tree above, the root of the tree is the node that contains the value <em>3</em>. <em>(For whatever reason, in Computer Science trees are generally upside-down with the root at the top and the leaves at the bottom.)</em></p>

<h3>Depth First Traversal</h3>

<p>There are three ways to do a depth-first traversal of a tree:</p>

<h4>1. Pre-order Traversal</h4>

<p>The steps of a Pre-order traversal:</p>

<ol>
<li>Visit the current node and do something with the value found there.</li>
<li>Traverse the left subtree.</li>
<li>Traverse the right subtree.</li>
</ol>


<p>An OCaml function to do a preorder traversal is defined as follows:</p>

<figure class='code'><figcaption><span>[ ] [title: preorder tree traversal function] </span></figcaption>
<div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='ocaml'><span class='line'><span class="k">let</span> <span class="k">rec</span> <span class="n">preorder_traverse</span> <span class="n">t</span> <span class="o">=</span> <span class="k">match</span> <span class="n">t</span> <span class="k">with</span>
</span><span class='line'>  <span class="o">|</span> <span class="nc">Empty</span>           <span class="o">-&gt;</span> <span class="bp">()</span>
</span><span class='line'>  <span class="o">|</span> <span class="nc">Leaf</span>  <span class="k">value</span>     <span class="o">-&gt;</span> <span class="nn">Printf</span><span class="p">.</span><span class="n">printf</span> <span class="s2">&quot;%s &quot;</span> <span class="k">value</span>
</span><span class='line'>  <span class="o">|</span> <span class="nc">Node</span> <span class="o">(</span><span class="n">l</span><span class="o">,</span><span class="k">value</span><span class="o">,</span><span class="n">r</span><span class="o">)-&gt;</span> <span class="nn">Printf</span><span class="p">.</span><span class="n">printf</span> <span class="s2">&quot;%s &quot;</span> <span class="k">value</span><span class="o">;</span>
</span><span class='line'>                       <span class="n">preorder_traverse</span> <span class="n">l</span><span class="o">;</span>
</span><span class='line'>                       <span class="n">preorder_traverse</span> <span class="n">r</span>
</span></code></pre></td></tr></table></div></figure>


<p>The recursive <em>preorder_traverse</em> function (note the <em>rec</em> in the function definition) takes a tree and uses <a href="http://en.wikipedia.org/wiki/Pattern_matching">pattern matching</a> to determine what to do with each variant in the <em>tree</em> type. If <em>t</em> is an <em>Empty</em> we do nothing (empty parens <em>()</em> also known as <em>unit</em> in OCaml) . If It&rsquo;s a <em>Leaf</em> we print it&rsquo;s value. If it&rsquo;s a <em>Node</em> we print it&rsquo;s value and then call <em>preorder_traverse</em> on the left tree of the node and then call <em>preorder_traverse</em> on the right tree of the node.</p>

<p>Running this on our tree above we get (You&rsquo;ve been typing the code into the <a href="http://try.ocamlpro.com/">online OCaml REPL</a> right?) :</p>

<pre><code># preorder_traverse t ;;
3 1 0 2 5 4 6 - : unit = ()
</code></pre>

<h4>2. In-order Traversal</h4>

<p>The steps of an In-order traversal:</p>

<ol>
<li>Traverse the left subtree.</li>
<li>Visit current node and do something with value found there.</li>
<li>Traverse the right subtree.</li>
</ol>


<p>Here&rsquo;s the OCaml function for an inorder traversal:</p>

<figure class='code'><figcaption><span>[ ] [title: inorder tree traversal function] </span></figcaption>
<div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='ocaml'><span class='line'><span class="k">let</span> <span class="k">rec</span> <span class="n">inorder_traverse</span> <span class="n">t</span> <span class="o">=</span> <span class="k">match</span> <span class="n">t</span> <span class="k">with</span>
</span><span class='line'>  <span class="o">|</span>  <span class="nc">Empty</span>            <span class="o">-&gt;</span> <span class="bp">()</span>
</span><span class='line'>  <span class="o">|</span>  <span class="nc">Leaf</span> <span class="k">value</span>       <span class="o">-&gt;</span> <span class="nn">Printf</span><span class="p">.</span><span class="n">printf</span> <span class="s2">&quot;%s &quot;</span> <span class="k">value</span>
</span><span class='line'>  <span class="o">|</span>  <span class="nc">Node</span> <span class="o">(</span><span class="n">l</span><span class="o">,</span><span class="k">value</span><span class="o">,</span><span class="n">r</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="n">inorder_traverse</span> <span class="n">l</span> <span class="o">;</span>
</span><span class='line'>                         <span class="nn">Printf</span><span class="p">.</span><span class="n">printf</span>  <span class="s2">&quot;%s &quot;</span> <span class="k">value</span><span class="o">;</span>
</span><span class='line'>                         <span class="n">inorder_traverse</span> <span class="n">r</span>
</span></code></pre></td></tr></table></div></figure>


<p>Running this on our tree we get:</p>

<pre><code># inorder_traverse t ;;
0 1 2 3 4 5 6 - : unit = ()
</code></pre>

<p>Now you can get an idea of why we arranged the values in our tree as we did.</p>

<h4>3. Post-order Traversal</h4>

<p>Now you probably get the idea. For postorder we&rsquo;re going to traverse the left subtree then traverse the right subtree and finally visit the current node and do something with it&rsquo;s value:</p>

<figure class='code'><figcaption><span>[ ] [title: inorder tree traversal function] </span></figcaption>
<div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='ocaml'><span class='line'><span class="k">let</span> <span class="k">rec</span> <span class="n">postorder_traverse</span> <span class="n">t</span> <span class="o">=</span> <span class="k">match</span> <span class="n">t</span> <span class="k">with</span>
</span><span class='line'>  <span class="o">|</span>  <span class="nc">Empty</span>  <span class="o">-&gt;</span> <span class="bp">()</span>
</span><span class='line'>  <span class="o">|</span>  <span class="nc">Leaf</span> <span class="k">value</span> <span class="o">-&gt;</span> <span class="nn">Printf</span><span class="p">.</span><span class="n">printf</span> <span class="s2">&quot;%s &quot;</span> <span class="k">value</span>
</span><span class='line'>  <span class="o">|</span>  <span class="nc">Node</span> <span class="o">(</span><span class="n">l</span><span class="o">,</span><span class="k">value</span><span class="o">,</span><span class="n">r</span><span class="o">)</span> <span class="o">-&gt;</span>  <span class="n">postorder_traverse</span> <span class="n">l</span><span class="o">;</span>
</span><span class='line'>                          <span class="n">postorder_traverse</span> <span class="n">r</span><span class="o">;</span>
</span><span class='line'>                          <span class="nn">Printf</span><span class="p">.</span><span class="n">printf</span>  <span class="s2">&quot;%s &quot;</span> <span class="k">value</span>
</span></code></pre></td></tr></table></div></figure>


<p>And when we run this on our tree we get:</p>

<pre><code># postorder_traverse t ;;
0 2 1 4 6 5 3 - : unit = ()
</code></pre>

<p><em>As an aside, instead of just printing the current value we&rsquo;d probably want to make each of our traversal functions more general. This is functional programming, after all, and one of the great &ldquo;wins&rdquo; of functional programming is being able to pass functions to functions - function composition. We can generalize our traversal functions by passing in a function that will do something with the value:</em></p>

<figure class='code'><figcaption><span>[ ] [title: generalized inorder tree traversal function] </span></figcaption>
<div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='ocaml'><span class='line'><span class="k">let</span> <span class="k">rec</span> <span class="n">postorder_traverse</span> <span class="n">f</span> <span class="n">t</span> <span class="o">=</span> <span class="k">match</span> <span class="n">t</span> <span class="k">with</span>
</span><span class='line'>  <span class="o">|</span>  <span class="nc">Empty</span>            <span class="o">-&gt;</span> <span class="bp">()</span>
</span><span class='line'>  <span class="o">|</span>  <span class="nc">Leaf</span> <span class="k">value</span>       <span class="o">-&gt;</span> <span class="n">f</span> <span class="k">value</span>
</span><span class='line'>  <span class="o">|</span>  <span class="nc">Node</span> <span class="o">(</span><span class="n">l</span><span class="o">,</span><span class="k">value</span><span class="o">,</span><span class="n">r</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="n">postorder_traverse</span> <span class="n">f</span> <span class="n">l</span><span class="o">;</span>
</span><span class='line'>                         <span class="n">postorder_traverse</span> <span class="n">f</span> <span class="n">r</span><span class="o">;</span>
</span><span class='line'>                         <span class="n">f</span> <span class="k">value</span>
</span></code></pre></td></tr></table></div></figure>


<p><em>Then we could use this version of postorder_traverse to print the values in our tree:</em></p>

<pre><code># postorder_traverse (fun n -&gt; Printf.printf "%s " n) t;;
0 2 1 4 6 5 3 - : unit = ()
</code></pre>

<p>Notice that none of these depth first traversals of the tree will work for us in creating the <em>dot</em> file for graphviz. We need some other way to traverse the tree&hellip;</p>

<p>We need something that gives us (not actual <em>dot</em> code, but you get the idea):
    3 -> 1
    3 -> 5
    1 -> 0
    1 -> 2
    5 -> 4
    5 -> 6</p>

<p>Which brings us to&hellip;</p>

<h3>Breadth First (or Level Order) Traversal</h3>

<p>A Level Order traversal means we&rsquo;re traversing each level of the tree. A Level order traversal of our tree above would look like(line breaks added to emphasize the levels of the tree):</p>

<pre><code>3 
1 5 
0 2 4 6
</code></pre>

<p>This still isn&rsquo;t quite what we need yet, but it seems we&rsquo;re getting closer.</p>

<p>Before we go on, let&rsquo;s define a couple of helper functions that we&rsquo;ll need to construct our <em>dot</em> file.</p>

<p>First off, we&rsquo;ll need to construct a string that gets written to the <em>dot</em> file. It would be good to have a function that converts each of the 3 variants that can make up a <em>tree</em> type to a string in <em>dot</em> format that represents the node in the graph:</p>

<figure class='code'><figcaption><span>[ ] [title: to_dot_node] </span></figcaption>
<div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='ocaml'><span class='line'><span class="k">let</span> <span class="n">to_dot_node</span> <span class="o">(</span><span class="n">t</span><span class="o">:</span> <span class="k">&#39;</span><span class="n">a</span> <span class="n">tree</span><span class="o">)</span> <span class="o">:</span> <span class="kt">string</span> <span class="o">=</span> <span class="k">match</span> <span class="n">t</span> <span class="k">with</span>
</span><span class='line'>  <span class="o">|</span> <span class="nc">Empty</span> <span class="o">-&gt;</span> <span class="s2">&quot;&quot;</span>
</span><span class='line'>  <span class="o">|</span> <span class="nc">Node</span><span class="o">(_,</span><span class="n">x</span><span class="o">,_)</span> <span class="o">-&gt;</span> <span class="s2">&quot;{N&quot;</span><span class="o">^</span><span class="n">x</span><span class="o">^</span><span class="s2">&quot;[label=</span><span class="se">\&quot;</span><span class="s2">&quot;</span> <span class="o">^</span><span class="n">x</span><span class="o">^</span><span class="s2">&quot;</span><span class="se">\&quot;</span><span class="s2">]}&quot;</span>
</span><span class='line'>  <span class="o">|</span> <span class="nc">Leaf</span> <span class="n">x</span> <span class="o">-&gt;</span>      <span class="s2">&quot;{L&quot;</span><span class="o">^</span><span class="n">x</span><span class="o">^</span><span class="s2">&quot;[shape=box,label=</span><span class="se">\&quot;</span><span class="s2">&quot;</span> <span class="o">^</span><span class="n">x</span><span class="o">^</span> <span class="s2">&quot;</span><span class="se">\&quot;</span><span class="s2">]}&quot;</span>
</span></code></pre></td></tr></table></div></figure>


<p>Notice that in this function definition we explicitly specified that the <em>t</em> argument passed to this function should be of type <em>&lsquo;a tree</em> and the output is of type <em>string</em> - this is completely optional as the compiler can figure out the types of the arguments using <em>type inference</em>, but it can make the code easier to read. <em>(Note: ^ is the string concatenation operator in OCaml)</em></p>

<p>If you pasted that function in the REPL you&rsquo;ll see:</p>

<pre><code>val to_dot_node : string tree -&gt; string = &lt;fun&gt; 
</code></pre>

<p>Which means that this is a function that takes a <em>string tree</em> and returns a <em>string</em>.</p>

<p>We can try running this function on our tree:</p>

<pre><code># to_dot_node t ;;
- : string = "{N3[label=\"3\"]}"
</code></pre>

<p>Which is the label of the root of our tree (3).</p>

<p>Next, we&rsquo;ll define a function that given two inputs of type <em>&lsquo;a tree</em> will return an <em>edge</em> (a line between two nodes in the tree) in <em>dot</em> format:</p>

<figure class='code'><figcaption><span>[ ] [title: edge] </span></figcaption>
<div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='ocaml'><span class='line'><span class="k">let</span> <span class="n">edge</span> <span class="o">(</span><span class="n">n1</span><span class="o">:</span> <span class="k">&#39;</span><span class="n">a</span> <span class="n">tree</span> <span class="o">)</span> <span class="o">(</span><span class="n">n2</span> <span class="o">:</span> <span class="k">&#39;</span><span class="n">a</span> <span class="n">tree</span> <span class="o">)</span> <span class="o">:</span> <span class="kt">string</span> <span class="o">=</span> <span class="o">(</span><span class="n">to_dot_node</span> <span class="n">n1</span><span class="o">)^</span><span class="s2">&quot;--&quot;</span><span class="o">^(</span><span class="n">to_dot_node</span> <span class="n">n2</span><span class="o">)^</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span>
</span></code></pre></td></tr></table></div></figure>


<p>Now we can go on to define our <em>tree_to_dot</em> function:</p>

<figure class='code'><figcaption><span>[ ] [title: tree_to_dot] </span></figcaption>
<div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
</pre></td><td class='code'><pre><code class='ocaml'><span class='line'><span class="k">let</span> <span class="k">rec</span> <span class="n">tree_to_dot</span>  <span class="n">acc</span> <span class="n">t</span> <span class="o">=</span>
</span><span class='line'>  <span class="k">match</span> <span class="n">t</span> <span class="k">with</span>
</span><span class='line'>  <span class="o">|</span> <span class="nc">Empty</span> <span class="o">-&gt;</span> <span class="n">acc</span>
</span><span class='line'>  <span class="o">|</span> <span class="nc">Leaf</span> <span class="o">_</span> <span class="k">as</span> <span class="n">leaf</span> <span class="o">-&gt;</span>   <span class="n">acc</span> <span class="o">^</span> <span class="o">(</span><span class="n">to_dot_node</span> <span class="n">leaf</span><span class="o">)</span>
</span><span class='line'>  <span class="o">|</span> <span class="nc">Node</span><span class="o">(</span> <span class="o">(</span><span class="nc">Node</span> <span class="o">(_,_,_)</span> <span class="k">as</span> <span class="n">n</span><span class="o">)</span> <span class="o">,</span> <span class="o">_,</span>  <span class="o">(</span><span class="nc">Leaf</span> <span class="o">_</span> <span class="k">as</span> <span class="n">leaf</span><span class="o">))</span>
</span><span class='line'>  <span class="o">|</span> <span class="nc">Node</span><span class="o">(</span> <span class="nc">Leaf</span> <span class="o">_</span> <span class="k">as</span> <span class="n">leaf</span><span class="o">,</span> <span class="o">_,</span> <span class="o">(</span><span class="nc">Node</span> <span class="o">(_,_,_)</span> <span class="k">as</span> <span class="n">n</span><span class="o">))</span>     <span class="o">-&gt;</span>
</span><span class='line'>      <span class="o">(</span><span class="n">edge</span> <span class="n">t</span> <span class="n">n</span><span class="o">)</span> <span class="o">^</span> <span class="o">(</span><span class="n">edge</span> <span class="n">t</span> <span class="n">leaf</span><span class="o">)</span> <span class="o">^(</span><span class="n">tree_to_dot</span> <span class="n">acc</span> <span class="n">n</span><span class="o">)</span>
</span><span class='line'>  <span class="o">|</span> <span class="nc">Node</span><span class="o">(</span> <span class="o">(</span> <span class="nc">Node</span><span class="o">(_,_,_)</span>  <span class="k">as</span> <span class="n">n</span><span class="o">)</span> <span class="o">,</span> <span class="o">_,</span>  <span class="nc">Empty</span><span class="o">)</span>
</span><span class='line'>  <span class="o">|</span> <span class="nc">Node</span><span class="o">(</span> <span class="nc">Empty</span><span class="o">,</span> <span class="o">_,</span> <span class="o">(</span><span class="nc">Node</span><span class="o">(_,_,_)</span> <span class="k">as</span> <span class="n">n</span><span class="o">))</span>    <span class="o">-&gt;</span>
</span><span class='line'>      <span class="o">(</span><span class="n">edge</span> <span class="n">t</span> <span class="n">n</span><span class="o">)</span> <span class="o">^</span> <span class="o">(</span><span class="n">tree_to_dot</span> <span class="n">acc</span> <span class="n">n</span><span class="o">)</span>
</span><span class='line'>  <span class="o">|</span> <span class="nc">Node</span><span class="o">(</span> <span class="o">(</span> <span class="nc">Leaf</span> <span class="o">_</span>  <span class="k">as</span> <span class="n">leaf</span><span class="o">),</span> <span class="o">_,</span> <span class="nc">Empty</span><span class="o">)</span>
</span><span class='line'>  <span class="o">|</span> <span class="nc">Node</span><span class="o">(</span> <span class="nc">Empty</span><span class="o">,</span> <span class="o">_,(</span><span class="nc">Leaf</span> <span class="o">_</span> <span class="k">as</span> <span class="n">leaf</span><span class="o">))</span>   <span class="o">-&gt;</span>
</span><span class='line'>      <span class="o">(</span><span class="n">edge</span> <span class="n">t</span> <span class="n">leaf</span><span class="o">)</span>
</span><span class='line'>  <span class="o">|</span> <span class="nc">Node</span><span class="o">(</span> <span class="o">(</span><span class="nc">Leaf</span> <span class="o">_</span> <span class="k">as</span> <span class="n">left</span><span class="o">),</span> <span class="o">_,</span> <span class="o">(</span><span class="nc">Leaf</span> <span class="o">_</span> <span class="k">as</span> <span class="n">right</span><span class="o">))</span> <span class="o">-&gt;</span>
</span><span class='line'>      <span class="o">(</span><span class="n">edge</span> <span class="n">t</span> <span class="n">left</span><span class="o">)</span> <span class="o">^</span> <span class="o">(</span><span class="n">edge</span> <span class="n">t</span> <span class="n">right</span><span class="o">)</span>
</span><span class='line'>  <span class="o">|</span> <span class="nc">Node</span><span class="o">(</span> <span class="nc">Empty</span><span class="o">,</span> <span class="o">_,</span> <span class="nc">Empty</span><span class="o">)</span> <span class="o">-&gt;</span>
</span><span class='line'>      <span class="n">acc</span>
</span><span class='line'>  <span class="o">|</span> <span class="nc">Node</span><span class="o">(</span> <span class="o">(</span><span class="nc">Node</span> <span class="o">(_,_,_)</span> <span class="k">as</span> <span class="n">nl</span><span class="o">)</span> <span class="o">,</span> <span class="o">_,</span> <span class="o">(</span><span class="nc">Node</span><span class="o">(_,_,_)</span> <span class="k">as</span> <span class="n">nr</span><span class="o">))</span> <span class="o">-&gt;</span>
</span><span class='line'>      <span class="o">(</span><span class="n">edge</span> <span class="n">t</span> <span class="n">nl</span><span class="o">)^(</span><span class="n">edge</span> <span class="n">t</span> <span class="n">nr</span><span class="o">)^(</span><span class="n">tree_to_dot</span> <span class="n">acc</span> <span class="n">nl</span><span class="o">)^(</span><span class="n">tree_to_dot</span> <span class="n">acc</span> <span class="n">nr</span><span class="o">)</span>
</span></code></pre></td></tr></table></div></figure>


<p>The first argument to <em>tree_to_dot</em> is <em>acc</em> which is specified as being a string. <em>acc</em> is our accumulator: we&rsquo;ll use it to build up our <em>dot</em> file. Notice that the function is specified as being recursive ( the <em>rec</em> specifies that the function can call itself).</p>

<p>Our pattern match covers all of the potential cases we might encounter. The first one matches <em>t</em> with <em>Empty</em> and in that case returns our accumulator <em>acc</em>. The next match is against <em>Leaf _</em> (underscore there meaning that the <em>Leaf</em> could contain any value). If <em>t</em> is a Leaf, then we&rsquo;ll append the <em>Leaf</em>&rsquo;s <em>dot</em> node format to the accumulator.</p>

<p>After this we do several matches where <em>t</em> is a <em>Node</em> variant. In order to create an <em>edge</em> we need to know about the children of the current <em>Node</em>. Pattern Matching allows us to do this, the first pattern match against <em>Node</em> is:</p>

<pre><code>  | Node( (Node (_,_,_) as n) , _,  (Leaf _ as leaf))
  | Node( Leaf _ as leaf, _, (Node (_,_,_) as n))     -&gt;
      (edge t n) ^ (edge t leaf) ^(tree_to_dot acc n)
</code></pre>

<p>We&rsquo;re considering two cases here:</p>

<ol>
<li>The case where the <em>Node</em> contains a <em>Node</em> as the left sub-tree and a <em>Leaf</em> in the right sub-tree.</li>
<li>The case where the <em>Node</em> contains a <em>Leaf</em> as the left sub-tree and a <em>Node</em> in the right sub-tree.</li>
</ol>


<p>If either of these cases match, we then create an edge from the current <em>Node</em> (which is <em>t</em>) to the next <em>Node</em> (which is <em>n</em>) and an edge from the current <em>Node</em> (<em>t</em>) to the <em>Leaf</em> (<em>leaf</em>). And we concatenate that with the recursive call to <em>tree_to_dot acc n</em>, meaning we&rsquo;re passing the child node <em>n</em> on to <em>tree_to_dot</em> for further processing.</p>

<p>Next we match the two cases where there&rsquo;s a single child <em>Node</em> and a single <em>Empty</em> node. If so we create an edge from the current <em>Node</em> (<em>t</em>) to the child <em>Node</em> and concatenat that with the call to <em>tree_to_dot</em> given the child <em>Node</em> <em>n</em>.</p>

<p>After that we match the two cases where one child of the <em>Node</em> is a <em>Leaf</em> and the other is <em>Empty</em>. If these cases match we only return an edge from the current <em>Node</em> <em>t</em> to the child <em>Leaf</em>. No recursive call to <em>tree_to_dot</em> in this case. Since there are no child <em>Node</em>s, there&rsquo;s no reason to.</p>

<p>If both sub-trees of the current <em>Node</em> <em>t</em> are <em>Leaf</em>s then the next pattern matches and we concatenate the two edges from the current <em>Node</em> <em>t</em> to each <em>Leaf</em>.</p>

<p>In the next case we check for both sub-trees of the <em>Node</em> being <em>Empty</em> and if that case matches we just return the accumulator.</p>

<p>Finally, we cover the case where both sub-trees of the current node are <em>Node</em>s. Notice that if this case matches we have two calls to <em>tree_to_dot</em> - one for the left subtree and the other for the right subtree.</p>

<p>Now we just need to do a bit of housekeeping to write out the complete <em>dot</em> file:</p>

<figure class='code'><figcaption><span>[ ] [title: tree_to_dotfile] </span></figcaption>
<div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='ocaml'><span class='line'><span class="k">let</span> <span class="n">tree_to_dotfile</span> <span class="n">t</span> <span class="n">file</span> <span class="o">=</span>
</span><span class='line'>  <span class="k">let</span> <span class="n">dot_tree</span> <span class="o">=</span> <span class="s2">&quot;graph tree {</span><span class="se">\n</span><span class="s2">&quot;</span><span class="o">^(</span><span class="n">tree_to_dot</span> <span class="s2">&quot; &quot;</span> <span class="n">t</span><span class="o">)^</span><span class="s2">&quot;}&quot;</span> <span class="k">in</span>
</span><span class='line'>  <span class="k">let</span> <span class="n">channel</span> <span class="o">=</span> <span class="n">open_out</span> <span class="n">file</span> <span class="k">in</span>
</span><span class='line'>  <span class="n">output_string</span> <span class="n">channel</span> <span class="n">dot_tree</span><span class="o">;</span>
</span><span class='line'>  <span class="n">close_out</span> <span class="n">channel</span>
</span></code></pre></td></tr></table></div></figure>


<p>This function won&rsquo;t work in the Try OCaml REPL since it writes to a file. But maybe by now you&rsquo;ve been convinced to install OCaml. If so, here&rsquo;s the whole program so you can compile it:</p>

<figure class='code'><figcaption><span>[ ] [title: tree.ml] </span></figcaption>
<div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
<span class='line-number'>50</span>
<span class='line-number'>51</span>
</pre></td><td class='code'><pre><code class='ocaml'><span class='line'><span class="k">type</span> <span class="k">&#39;</span><span class="n">a</span> <span class="n">tree</span> <span class="o">=</span> <span class="nc">Empty</span> <span class="o">|</span> <span class="nc">Leaf</span> <span class="k">of</span> <span class="k">&#39;</span><span class="n">a</span> <span class="o">|</span> <span class="nc">Node</span> <span class="k">of</span> <span class="k">&#39;</span><span class="n">a</span> <span class="n">tree</span> <span class="o">*</span> <span class="k">&#39;</span><span class="n">a</span> <span class="o">*</span> <span class="k">&#39;</span><span class="n">a</span> <span class="n">tree</span>
</span><span class='line'>
</span><span class='line'><span class="k">let</span> <span class="n">to_dot_node</span> <span class="o">(</span><span class="n">t</span><span class="o">:</span> <span class="k">&#39;</span><span class="n">a</span> <span class="n">tree</span><span class="o">)</span> <span class="o">:</span> <span class="kt">string</span> <span class="o">=</span> <span class="k">match</span> <span class="n">t</span> <span class="k">with</span>
</span><span class='line'>  <span class="o">|</span> <span class="nc">Empty</span> <span class="o">-&gt;</span> <span class="s2">&quot;&quot;</span>
</span><span class='line'>  <span class="o">|</span> <span class="nc">Node</span><span class="o">(_,</span><span class="n">x</span><span class="o">,_)</span> <span class="o">-&gt;</span> <span class="s2">&quot;{N&quot;</span><span class="o">^</span><span class="n">x</span><span class="o">^</span><span class="s2">&quot;[label=</span><span class="se">\&quot;</span><span class="s2">&quot;</span> <span class="o">^</span><span class="n">x</span><span class="o">^</span><span class="s2">&quot;</span><span class="se">\&quot;</span><span class="s2">]}&quot;</span>
</span><span class='line'>  <span class="o">|</span> <span class="nc">Leaf</span> <span class="n">x</span> <span class="o">-&gt;</span>      <span class="s2">&quot;{L&quot;</span><span class="o">^</span><span class="n">x</span><span class="o">^</span><span class="s2">&quot;[shape=box,label=</span><span class="se">\&quot;</span><span class="s2">&quot;</span> <span class="o">^</span><span class="n">x</span><span class="o">^</span> <span class="s2">&quot;</span><span class="se">\&quot;</span><span class="s2">]}&quot;</span>
</span><span class='line'>
</span><span class='line'><span class="k">let</span> <span class="n">edge</span> <span class="o">(</span><span class="n">n1</span><span class="o">:</span> <span class="k">&#39;</span><span class="n">a</span> <span class="n">tree</span> <span class="o">)</span> <span class="o">(</span><span class="n">n2</span> <span class="o">:</span> <span class="k">&#39;</span><span class="n">a</span> <span class="n">tree</span> <span class="o">)</span> <span class="o">:</span> <span class="kt">string</span> <span class="o">=</span> <span class="o">(</span><span class="n">to_dot_node</span> <span class="n">n1</span><span class="o">)^</span><span class="s2">&quot;--&quot;</span><span class="o">^(</span><span class="n">to_dot_node</span> <span class="n">n2</span><span class="o">)^</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span>
</span><span class='line'>
</span><span class='line'><span class="k">let</span> <span class="k">rec</span> <span class="n">tree_to_dot</span> <span class="o">(</span><span class="n">acc</span> <span class="o">:</span> <span class="kt">string</span><span class="o">)</span> <span class="o">(</span><span class="n">t</span> <span class="o">:</span> <span class="k">&#39;</span><span class="n">a</span> <span class="n">tree</span><span class="o">)</span> <span class="o">:</span> <span class="kt">string</span> <span class="o">=</span>
</span><span class='line'>  <span class="k">match</span> <span class="n">t</span> <span class="k">with</span>
</span><span class='line'>  <span class="o">|</span> <span class="nc">Empty</span> <span class="o">-&gt;</span> <span class="n">acc</span>
</span><span class='line'>  <span class="o">|</span> <span class="nc">Leaf</span> <span class="o">_</span> <span class="k">as</span> <span class="n">leaf</span> <span class="o">-&gt;</span>   <span class="n">acc</span> <span class="o">^</span> <span class="o">(</span><span class="n">to_dot_node</span> <span class="n">leaf</span><span class="o">)</span>
</span><span class='line'>  <span class="o">|</span> <span class="nc">Node</span><span class="o">(</span> <span class="o">(</span><span class="nc">Node</span> <span class="o">(_,_,_)</span> <span class="k">as</span> <span class="n">n</span><span class="o">)</span> <span class="o">,</span> <span class="o">_,</span>  <span class="o">(</span><span class="nc">Leaf</span> <span class="o">_</span> <span class="k">as</span> <span class="n">leaf</span><span class="o">))</span>
</span><span class='line'>  <span class="o">|</span> <span class="nc">Node</span><span class="o">(</span> <span class="nc">Leaf</span> <span class="o">_</span> <span class="k">as</span> <span class="n">leaf</span><span class="o">,</span> <span class="o">_,</span> <span class="o">(</span><span class="nc">Node</span> <span class="o">(_,_,_)</span> <span class="k">as</span> <span class="n">n</span><span class="o">))</span>     <span class="o">-&gt;</span>
</span><span class='line'>      <span class="o">(</span><span class="n">edge</span> <span class="n">t</span> <span class="n">n</span><span class="o">)</span> <span class="o">^</span> <span class="o">(</span><span class="n">edge</span> <span class="n">t</span> <span class="n">leaf</span><span class="o">)</span> <span class="o">^(</span><span class="n">tree_to_dot</span> <span class="n">acc</span> <span class="n">n</span><span class="o">)</span>
</span><span class='line'>  <span class="o">|</span> <span class="nc">Node</span><span class="o">(</span> <span class="o">(</span> <span class="nc">Node</span><span class="o">(_,_,_)</span>  <span class="k">as</span> <span class="n">n</span><span class="o">)</span> <span class="o">,</span> <span class="o">_,</span>  <span class="nc">Empty</span><span class="o">)</span>
</span><span class='line'>  <span class="o">|</span> <span class="nc">Node</span><span class="o">(</span> <span class="nc">Empty</span><span class="o">,</span> <span class="o">_,</span> <span class="o">(</span><span class="nc">Node</span><span class="o">(_,_,_)</span> <span class="k">as</span> <span class="n">n</span><span class="o">))</span>    <span class="o">-&gt;</span>
</span><span class='line'>      <span class="o">(</span><span class="n">edge</span> <span class="n">t</span> <span class="n">n</span><span class="o">)</span> <span class="o">^</span> <span class="o">(</span><span class="n">tree_to_dot</span> <span class="n">acc</span> <span class="n">n</span><span class="o">)</span>
</span><span class='line'>  <span class="o">|</span> <span class="nc">Node</span><span class="o">(</span> <span class="o">(</span> <span class="nc">Leaf</span> <span class="o">_</span>  <span class="k">as</span> <span class="n">leaf</span><span class="o">),</span> <span class="o">_,</span> <span class="nc">Empty</span><span class="o">)</span>
</span><span class='line'>  <span class="o">|</span> <span class="nc">Node</span><span class="o">(</span> <span class="nc">Empty</span><span class="o">,</span> <span class="o">_,(</span><span class="nc">Leaf</span> <span class="o">_</span> <span class="k">as</span> <span class="n">leaf</span><span class="o">))</span>   <span class="o">-&gt;</span>
</span><span class='line'>      <span class="o">(</span><span class="n">edge</span> <span class="n">t</span> <span class="n">leaf</span><span class="o">)</span>
</span><span class='line'>  <span class="o">|</span> <span class="nc">Node</span><span class="o">(</span> <span class="o">(</span><span class="nc">Leaf</span> <span class="o">_</span> <span class="k">as</span> <span class="n">left</span><span class="o">),</span> <span class="o">_,</span> <span class="o">(</span><span class="nc">Leaf</span> <span class="o">_</span> <span class="k">as</span> <span class="n">right</span><span class="o">))</span> <span class="o">-&gt;</span>
</span><span class='line'>      <span class="o">(</span><span class="n">edge</span> <span class="n">t</span> <span class="n">left</span><span class="o">)</span> <span class="o">^</span> <span class="o">(</span><span class="n">edge</span> <span class="n">t</span> <span class="n">right</span><span class="o">)</span>
</span><span class='line'>  <span class="o">|</span> <span class="nc">Node</span><span class="o">(</span> <span class="nc">Empty</span><span class="o">,</span> <span class="o">_,</span> <span class="nc">Empty</span><span class="o">)</span> <span class="o">-&gt;</span>
</span><span class='line'>      <span class="n">acc</span>
</span><span class='line'>  <span class="o">|</span> <span class="nc">Node</span><span class="o">(</span> <span class="o">(</span><span class="nc">Node</span> <span class="o">(_,_,_)</span> <span class="k">as</span> <span class="n">nl</span><span class="o">)</span> <span class="o">,</span> <span class="o">_,</span> <span class="o">(</span><span class="nc">Node</span><span class="o">(_,_,_)</span> <span class="k">as</span> <span class="n">nr</span><span class="o">))</span> <span class="o">-&gt;</span>
</span><span class='line'>      <span class="o">(</span><span class="n">edge</span> <span class="n">t</span> <span class="n">nl</span><span class="o">)^(</span><span class="n">edge</span> <span class="n">t</span> <span class="n">nr</span><span class="o">)^(</span><span class="n">tree_to_dot</span> <span class="n">acc</span> <span class="n">nl</span><span class="o">)^(</span><span class="n">tree_to_dot</span> <span class="n">acc</span> <span class="n">nr</span><span class="o">)</span>
</span><span class='line'>
</span><span class='line'><span class="k">let</span> <span class="n">tree_to_dotfile</span> <span class="n">t</span> <span class="n">file</span> <span class="o">=</span>
</span><span class='line'>  <span class="k">let</span> <span class="n">dot_tree</span> <span class="o">=</span> <span class="s2">&quot;graph tree {</span><span class="se">\n</span><span class="s2">&quot;</span><span class="o">^(</span><span class="n">tree_to_dot</span> <span class="s2">&quot; &quot;</span> <span class="n">t</span><span class="o">)^</span><span class="s2">&quot;}&quot;</span> <span class="k">in</span>
</span><span class='line'>  <span class="k">let</span> <span class="n">channel</span> <span class="o">=</span> <span class="n">open_out</span> <span class="n">file</span> <span class="k">in</span>
</span><span class='line'>  <span class="n">output_string</span> <span class="n">channel</span> <span class="n">dot_tree</span><span class="o">;</span>
</span><span class='line'>  <span class="n">close_out</span> <span class="n">channel</span><span class="o">;;</span>
</span><span class='line'>
</span><span class='line'><span class="k">let</span> <span class="n">t</span> <span class="o">=</span> <span class="nc">Node</span> <span class="o">(</span>
</span><span class='line'>              <span class="nc">Node</span> <span class="o">(</span>
</span><span class='line'>                    <span class="nc">Leaf</span> <span class="s2">&quot;0&quot;</span><span class="o">,</span>
</span><span class='line'>                    <span class="s2">&quot;1&quot;</span><span class="o">,</span>
</span><span class='line'>                    <span class="nc">Leaf</span> <span class="s2">&quot;2&quot;</span><span class="o">),</span>
</span><span class='line'>              <span class="s2">&quot;3&quot;</span><span class="o">,</span>
</span><span class='line'>              <span class="nc">Node</span> <span class="o">(</span>
</span><span class='line'>                    <span class="nc">Leaf</span> <span class="s2">&quot;4&quot;</span><span class="o">,</span>
</span><span class='line'>                    <span class="s2">&quot;5&quot;</span><span class="o">,</span>
</span><span class='line'>                    <span class="nc">Leaf</span> <span class="s2">&quot;6&quot;</span>
</span><span class='line'>              <span class="o">)</span>
</span><span class='line'>         <span class="o">)</span>
</span><span class='line'>
</span><span class='line'>
</span><span class='line'>
</span><span class='line'><span class="k">let</span> <span class="o">_</span> <span class="o">=</span> <span class="n">tree_to_dotfile</span> <span class="n">t</span> <span class="s2">&quot;tree.dot&quot;</span>
</span></code></pre></td></tr></table></div></figure>


<p>You can compile it with the following command:</p>

<pre><code>$ ocamlopt -o tree tree.ml
</code></pre>

<h3>That&rsquo;s all there is to it</h3>
</div>


  <footer>
    <p class="meta">
      
  

<span class="byline author vcard">Posted by <span class="fn">Phil Tomson</span></span>

      




<time class='entry-date' datetime='2014-05-14T11:55:00-07:00'><span class='date'><span class='date-month'>May</span> <span class='date-day'>14</span><span class='date-suffix'>th</span>, <span class='date-year'>2014</span></span> <span class='time'>11:55 am</span></time>
      


    </p>
    
      <div class="sharing">
  
  
  
</div>

    
    <p class="meta">
      
        <a class="basic-alignment left" href="/blog/2014/04/29/coding-pretty-little-trees-tree-meditation-number-1/" title="Previous Post: Coding Happy Little Trees: Tree Meditation #1">&laquo; Coding Happy Little Trees: Tree Meditation #1</a>
      
      
        <a class="basic-alignment right" href="/blog/2014/05/29/comparing-a-machine-learning-algorithm-implemented-in-f-number-and-ocaml/" title="Next Post: Comparing a Machine Learning algorithm implemented in F# and OCaml">Comparing a Machine Learning algorithm implemented in F# and OCaml &raquo;</a>
      
    </p>
  </footer>
</article>

  <section>
    <h1>Comments</h1>
    <div id="disqus_thread" aria-live="polite"><noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
</div>
  </section>

</div>

<aside class="sidebar">
  
    <section>
  <h1>Recent Posts</h1>
  <ul id="recent_posts">
    
      <li class="post">
        <a href="/blog/2017/02/02/funemployment/">FUNemployment</a>
      </li>
    
      <li class="post">
        <a href="/blog/2014/09/10/some-notes-on-building-and-running-mirage-unikernels-on-cubieboard2/">Some Notes on Building and Running Mirage Unikernels on Cubieboard2</a>
      </li>
    
      <li class="post">
        <a href="/blog/2014/07/09/core-dot-async-example/">Cooperative Concurrency in OCaml: A Core.Std.Async Example</a>
      </li>
    
      <li class="post">
        <a href="/blog/2014/05/30/stop-the-presses-ocaml-wins/">Stop the Presses: OCaml Wins in Terms of Speed</a>
      </li>
    
      <li class="post">
        <a href="/blog/2014/05/29/comparing-a-machine-learning-algorithm-implemented-in-f-number-and-ocaml/">Comparing a Machine Learning Algorithm Implemented in F# and OCaml</a>
      </li>
    
  </ul>
</section>

<section>
  <h1>GitHub Repos</h1>
  <ul id="gh_repos">
    <li class="loading">Status updating...</li>
  </ul>
  
  <a href="https://github.com/philtomson">@philtomson</a> on GitHub
  
  <script type="text/javascript">
    $(document).ready(function(){
        if (!window.jXHR){
            var jxhr = document.createElement('script');
            jxhr.type = 'text/javascript';
            jxhr.src = '/javascripts/libs/jXHR.js';
            var s = document.getElementsByTagName('script')[0];
            s.parentNode.insertBefore(jxhr, s);
        }

        github.showRepos({
            user: 'philtomson',
            count: 0,
            skip_forks: true,
            target: '#gh_repos'
        });
    });
  </script>
  <script src="/javascripts/github.js" type="text/javascript"> </script>
</section>





  
</aside>


    </div>
  </div>
  <footer role="contentinfo"><p>
  Copyright &copy; 2017 - Phil Tomson -
  <span class="credit">Powered by <a href="http://octopress.org">Octopress</a></span>
</p>

</footer>
  

<script type="text/javascript">
      var disqus_shortname = 'mylittlegardenofcode';
      
        
        // var disqus_developer = 1;
        var disqus_identifier = 'http://philtomson.github.io/blog/2014/05/14/drawing-happy-little-trees-tree-meditation-number-2/';
        var disqus_url = 'http://philtomson.github.io/blog/2014/05/14/drawing-happy-little-trees-tree-meditation-number-2/';
        var disqus_script = 'embed.js';
      
    (function () {
      var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
      dsq.src = '//' + disqus_shortname + '.disqus.com/' + disqus_script;
      (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    }());
</script>











</body>
</html>
